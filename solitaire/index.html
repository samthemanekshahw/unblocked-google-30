<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1" name="viewport"/>
<style>.menus,
.menu-popup,
.os-window,
.os-window .window-titlebar,
.os-window .window-title {
	cursor: default;
	-webkit-user-select: none;
	   -moz-user-select: none;
	    -ms-user-select: none;
	        user-select: none;
}

.os-window {
	contain: layout; /* contain: paint; seems to clip children to the padding-box, including for interaction, not just painting; it breaks being able to grab resize handles over the border */
	/* overflow: hidden; is also not usable for the same reason */
	/* I might be able to do either with overflow-clip-margin however (@TODO) */
	display: flex;
	flex-direction: column;
	/* will-change: width height left top; */
}
.window-content {
	flex: 1;
	min-height: 0px;
	/* Text overflowing the window frame is really ugly!
	overflow: hidden; would make it harder to enable scrollbars (overflow: auto !important)
	We want to allow scrollbars to be enabled easily (but not enable them),
	and we want to clip to the border of the window, without contents overlapping the border at all. */
	/* @FIXME: this breaks menu bar popup menus! (they get cut off, except for second level ones which are not descendents of the window; another reason to reimplement the menus!) */
    contain: layout paint;
}

.os-window .window-titlebar,
body > .window-titlebar {
	display: flex;
	flex-direction: row;
	align-items: center;
	white-space: nowrap;
	overflow: hidden;
	flex-shrink: 0;
}
.os-window .window-title-area {
	position: relative;
	flex: 1;
}

.os-window .window-titlebar .icon {
	vertical-align: bottom;
}

.os-window.maximized .handle,
.os-window.minimized-without-taskbar .handle {
	display: none; /* prevent resizing when window is minimized */
}

/* Fix dragging things (like windows) over iframes */
.dragging iframe {
	pointer-events: none;
}

.menus {
	display: flex;
	flex: 0 0 auto;
}
.menu-popup {
	position: absolute;
	box-sizing: border-box;
}
.menu-popup-table {
	border-collapse: collapse;
}
.menu-item {
	white-space: nowrap;
}
.menu-hr {
	display: block !important;
	height: 0;
	width: auto;
}
.menu-hotkey {
	display: inline !important;
}
.menu-item-checkbox-area,
.menu-item-submenu-area {
	min-width: 16px;
}
.menu-item-checkbox-area,
.menu-item-submenu-area {
	text-align: center;
}

/* .window-content .button-group {
	width: 85px;
}
.window-content .button-group > button {
	width: 95%;
	padding: 3px 5px;
} */

::before,
::after {
	pointer-events: none;
}

/*# sourceMappingURL=layout.css.map */</style>
<style>:root {
	/* These resources are generated. */
	/* JS: makeThemeCSSFile(renderThemeGraphics(getComputedStyle(document.documentElement))) */
	--checker: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAG0lEQVQYV2P8/////4MHDzIwHjhw4L+9vT0DAHAFCj6esq3FAAAAAElFTkSuQmCC");
	--button-active-border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h256v256h-256v-256z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h192v192h-192v-192z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	--button-normal-border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	--inset-deep-border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	--button-default-border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h256v256h-256v-256z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h96v32h-64v64h-32v-96z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M160%2064h32v128h-128v-32h96v-96z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M96%2096h64v64h-64v-64z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%09%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%22256%22%20height%3D%22256%22%20stroke-width%3D%2264%22%20stroke%3D%22%20rgb(0%2C%200%2C%200)%22%20fill%3D%22none%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 96 / 3px;
	--button-default-active-border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h256v256h-256v-256z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h192v192h-192v-192z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%09%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%22256%22%20height%3D%22256%22%20stroke-width%3D%2264%22%20stroke%3D%22%20rgb(0%2C%200%2C%200)%22%20fill%3D%22none%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	--scrollbar-arrows-ButtonText: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAJCAYAAABaMo5wAAAAW0lEQVQ4T2NkGGSAcZC5h4FWDvrPwEC02ShqkR0EkkAHuBxMyEKYWYQ8jKEOXQOyo/A5BuZwqqvBZiA+3xMbilQLIWqlcUJRimwPzjRELcdQZA6hREeR4eRoBgBoXhAK6oiMhwAAAABJRU5ErkJggg==");
	--scrollbar-arrows-GrayText: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAJCAYAAABaMo5wAAAAYElEQVQ4T2NkGGSAcZC5h4EmDmpoaPjf0NBAlNnoauGaQBLooYXLUEIWwswi5Chs6lB8gewofI6BOZwWajCCFZ/viQ1FqoUQtRI4oShFtgdnGqKWYyg1h6icQKklpOgHAM9mQArEvm5+AAAAAElFTkSuQmCC");
	--scrollbar-arrows-ButtonHilight: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAJCAYAAABaMo5wAAAAYElEQVQ4T2NkGGSAcZC5h4EmDvr///9/RkZGosxGVwvXBJJADy1chhKyEGYWIUdhU4fiC2RH4XMMzOG0UIMRrPh8T2woUi2EqJXACUUpsj040xC1HEOpOUTlBEotIUU/AKXFQAqyTJ6DAAAAAElFTkSuQmCC");
	--scrollbar-size: 13px;
	--scrollbar-button-inner-size: 9px;

	/* Colors */
	--ActiveBorder: rgb(192, 192, 192);
	--ActiveTitle: rgb(0, 0, 128);
	--AppWorkspace: rgb(128, 128, 128);
	--Background: rgb(0, 128, 128);
	--ButtonAlternateFace: rgb(180, 180, 180);
	--ButtonDkShadow: rgb(0, 0, 0);
	--ButtonFace: rgb(192, 192, 192);
	--ButtonHilight: rgb(255, 255, 255);
	--ButtonLight: rgb(223, 223, 223);
	--ButtonShadow: rgb(128, 128, 128);
	--ButtonText: rgb(0, 0, 0);
	--GradientActiveTitle: rgb(16, 132, 208);
	--GradientInactiveTitle: rgb(181, 181, 181);
	--GrayText: rgb(128, 128, 128);
	--Hilight: rgb(0, 0, 128);
	--HilightText: rgb(255, 255, 255);
	--HotTrackingColor: rgb(0, 0, 255);
	--InactiveBorder: rgb(192, 192, 192);
	--InactiveTitle: rgb(128, 128, 128);
	--InactiveTitleText: rgb(192, 192, 192);
	--InfoText: rgb(0, 0, 0);
	--InfoWindow: rgb(255, 255, 225);
	--Menu: rgb(192, 192, 192);
	--MenuText: rgb(0, 0, 0);
	--Scrollbar: rgb(192, 192, 192);
	--TitleText: rgb(255, 255, 255);
	--Window: rgb(255, 255, 255);
	--WindowFrame: rgb(0, 0, 0);
	--WindowText: rgb(0, 0, 0);
}

.inset-deep {
	border-style: solid;
	border-width: 1px;
	border-color: rgb(128, 128, 128) rgb(255, 255, 255) rgb(255, 255, 255) rgb(128, 128, 128);
	border-color: var(--ButtonShadow) var(--ButtonHilight) var(--ButtonHilight) var(--ButtonShadow);
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	color: rgb(0, 0, 0);
	color: var(--ButtonText);
	/* as fallback */
	position: relative;
	/* for pseudo element(s) */
	-o-border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	   border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	-o-border-image: var(--inset-deep-border-image);
	   border-image: var(--inset-deep-border-image);
	border-color: rgb(128, 128, 128);
	border-color: var(--ButtonShadow);
	border-style: solid;
	border-width: 2px 2px;
}
.outset-deep {
	border-style: solid;
	border-width: 1px;
	border-color: rgb(255, 255, 255) rgb(128, 128, 128) rgb(128, 128, 128) rgb(255, 255, 255);
	border-color: var(--ButtonHilight) var(--ButtonShadow) var(--ButtonShadow) var(--ButtonHilight);
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	color: rgb(0, 0, 0);
	color: var(--ButtonText);
	/* as fallback */
	position: relative;
	/* for pseudo element(s) */
	-o-border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	   border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	-o-border-image: var(--button-normal-border-image);
	   border-image: var(--button-normal-border-image);
	border-color: rgb(223, 223, 223) rgb(128, 128, 128) rgb(128, 128, 128) rgb(223, 223, 223);
	border-color: var(--ButtonLight) var(--ButtonShadow) var(--ButtonShadow) var(--ButtonLight);
	border-style: solid;
	border-width: 2px 2px;
}
.inset-shallow {
	border-style: solid;
	border-width: 1px;
	border-color: rgb(128, 128, 128) rgb(255, 255, 255) rgb(255, 255, 255) rgb(128, 128, 128);
	border-color: var(--ButtonShadow) var(--ButtonHilight) var(--ButtonHilight) var(--ButtonShadow);
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	color: rgb(0, 0, 0);
	color: var(--ButtonText);
}
.outset-shallow {
	border-style: solid;
	border-width: 1px;
	border-color: rgb(255, 255, 255) rgb(128, 128, 128) rgb(128, 128, 128) rgb(255, 255, 255);
	border-color: var(--ButtonHilight) var(--ButtonShadow) var(--ButtonShadow) var(--ButtonHilight);
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	color: rgb(0, 0, 0);
	color: var(--ButtonText);
}

button {
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	color: rgb(0, 0, 0);
	color: var(--ButtonText);
}
button:not(.lightweight) {
	outline: none; /* replaced with inner dotted focus ring (which is admittedly not so prominent...) */ border-style: solid; border-width: 1px; border-color: rgb(255, 255, 255) rgb(128, 128, 128) rgb(128, 128, 128) rgb(255, 255, 255); border-color: var(--ButtonHilight) var(--ButtonShadow) var(--ButtonShadow) var(--ButtonHilight); background-color: rgb(192, 192, 192); background-color: var(--ButtonFace); color: rgb(0, 0, 0); color: var(--ButtonText); /* as fallback */ position: relative; /* for pseudo element(s) */ -o-border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px; border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px; -o-border-image: var(--button-normal-border-image); border-image: var(--button-normal-border-image); border-color: rgb(223, 223, 223) rgb(128, 128, 128) rgb(128, 128, 128) rgb(223, 223, 223); border-color: var(--ButtonLight) var(--ButtonShadow) var(--ButtonShadow) var(--ButtonLight); border-style: solid; border-width: 2px 2px; border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px; border-image: var(--button-normal-border-image);
}
button:not(.lightweight).default {
	-o-border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h256v256h-256v-256z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h96v32h-64v64h-32v-96z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M160%2064h32v128h-128v-32h96v-96z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M96%2096h64v64h-64v-64z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%09%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%22256%22%20height%3D%22256%22%20stroke-width%3D%2264%22%20stroke%3D%22%20rgb(0%2C%200%2C%200)%22%20fill%3D%22none%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 96 / 3px;
	   border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h256v256h-256v-256z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h96v32h-64v64h-32v-96z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M160%2064h32v128h-128v-32h96v-96z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M96%2096h64v64h-64v-64z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%09%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%22256%22%20height%3D%22256%22%20stroke-width%3D%2264%22%20stroke%3D%22%20rgb(0%2C%200%2C%200)%22%20fill%3D%22none%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 96 / 3px;
	-o-border-image: var(--button-default-border-image);
	   border-image: var(--button-default-border-image);
}
button:not(.lightweight):enabled:hover:active {
	-o-border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h256v256h-256v-256z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h192v192h-192v-192z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	   border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h256v256h-256v-256z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h192v192h-192v-192z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	-o-border-image: var(--button-active-border-image);
	   border-image: var(--button-active-border-image);
}
button:not(.lightweight).default:enabled:hover:active {
	-o-border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h256v256h-256v-256z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h192v192h-192v-192z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%09%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%22256%22%20height%3D%22256%22%20stroke-width%3D%2264%22%20stroke%3D%22%20rgb(0%2C%200%2C%200)%22%20fill%3D%22none%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	   border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h256v256h-256v-256z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h192v192h-192v-192z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%09%3Crect%20x%3D%220%22%20y%3D%220%22%20width%3D%22256%22%20height%3D%22256%22%20stroke-width%3D%2264%22%20stroke%3D%22%20rgb(0%2C%200%2C%200)%22%20fill%3D%22none%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	-o-border-image: var(--button-default-active-border-image);
	   border-image: var(--button-default-active-border-image);
}

/* TODO: offset content on press! */
/* (this would need a child ELEMENT, wouldn't work with text nodes as direct descendants:) */
/*button:active > * {
	position: relative;
	left: 1px;
	top: 1px;
}
*/
/* also, this is more complicated; see Paint; the tool buttons translate when being pushed and when depressed, and these add together */
/* omg, a thought... what if I used feDisplacementMap SVG filter... */

button:not(.lightweight):focus::before {
	content: "";
	display: block;
	position: absolute;
	left: 2px;
	top: 2px;
	right: 2px;
	bottom: 2px;
	border: 1px dotted rgb(0, 0, 0);
	border: 1px dotted var(--ButtonDkShadow); /* ?? */
	/* TODO: get exact inset dimensions, and have corners without dots ideally */
	/* (could use outline instead of ::before at this point) */
}
button.lightweight {
	outline: none; /* these buttons are not usually keyboard accessible, or the focus it shown just by inset (menu buttons) */

	border-style: solid;
	border-width: 1px;
	border-color: transparent;
}
/* TODO: recommend preventing focus on click for lightweight buttons */
button.lightweight:enabled:hover {
	border-style: solid;
	border-width: 1px;
	border-color: rgb(255, 255, 255) rgb(128, 128, 128) rgb(128, 128, 128) rgb(255, 255, 255);
	border-color: var(--ButtonHilight) var(--ButtonShadow) var(--ButtonShadow) var(--ButtonHilight);
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	color: rgb(0, 0, 0);
	color: var(--ButtonText);
}
button.lightweight:enabled:hover:active, button.lightweight.pressing, button.lightweight.pressed {
	border-style: solid;
	border-width: 1px;
	border-color: rgb(128, 128, 128) rgb(255, 255, 255) rgb(255, 255, 255) rgb(128, 128, 128);
	border-color: var(--ButtonShadow) var(--ButtonHilight) var(--ButtonHilight) var(--ButtonShadow);
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	color: rgb(0, 0, 0);
	color: var(--ButtonText);
}
button:disabled {
	color: rgb(128, 128, 128);
	color: var(--GrayText);
	text-shadow: 1px 1px 0px rgb(255, 255, 255);
	text-shadow: 1px 1px 0px var(--ButtonHilight);
}
button:not(.lightweight).toggle:enabled:hover:active, button:not(.lightweight).pressing {
	border-style: solid;
	border-width: 1px;
	border-color: rgb(128, 128, 128) rgb(255, 255, 255) rgb(255, 255, 255) rgb(128, 128, 128);
	border-color: var(--ButtonShadow) var(--ButtonHilight) var(--ButtonHilight) var(--ButtonShadow);
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	color: rgb(0, 0, 0);
	color: var(--ButtonText);
	/* as fallback */
	position: relative;
	/* for pseudo element(s) */
	-o-border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	   border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	-o-border-image: var(--inset-deep-border-image);
	   border-image: var(--inset-deep-border-image);
}
button:not(.lightweight).toggle:enabled:hover:active, button:not(.lightweight).pressing {
	border-color: rgb(128, 128, 128);
	border-color: var(--ButtonShadow);
	border-style: solid;
	border-width: 2px 2px;
}
button:not(.lightweight).toggle.selected, button:not(.lightweight).pressed {
	border-style: solid;
	border-width: 1px;
	border-color: rgb(128, 128, 128) rgb(255, 255, 255) rgb(255, 255, 255) rgb(128, 128, 128);
	border-color: var(--ButtonShadow) var(--ButtonHilight) var(--ButtonHilight) var(--ButtonShadow);
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	color: rgb(0, 0, 0);
	color: var(--ButtonText);
	/* as fallback */
	position: relative;
	/* for pseudo element(s) */
	-o-border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	   border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	-o-border-image: var(--inset-deep-border-image);
	   border-image: var(--inset-deep-border-image);
}
button:not(.lightweight).toggle.selected, button:not(.lightweight).pressed {
	border-color: rgb(128, 128, 128);
	border-color: var(--ButtonShadow);
	border-style: solid;
	border-width: 2px 2px;
}
button:not(.lightweight).toggle.selected, button:not(.lightweight).pressed {
	background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAG0lEQVQYV2P8/////4MHDzIwHjhw4L+9vT0DAHAFCj6esq3FAAAAAElFTkSuQmCC") repeat;
	background: var(--checker) repeat;
	-ms-interpolation-mode: nearest-neighbor;
	    image-rendering: -moz-crisp-edges;
	    image-rendering: pixelated;
}

.os-window .window-titlebar,
body > .window-titlebar {
	background: rgb(0, 0, 128);
	background: var(--ActiveTitle);
	background: linear-gradient(to right, rgb(0, 0, 128) 0%, rgb(16, 132, 208) 100%);
	background: linear-gradient(to right, var(--ActiveTitle) 0%, var(--GradientActiveTitle) 100%);
	
	color: rgb(255, 255, 255);
	
	color: var(--TitleText);
}

.os-window .window-titlebar, body > .window-titlebar {
	font-family: 'Segoe UI', sans-serif;
	font-size: 12px;
}
.os-window.rtl .window-titlebar {
	background: linear-gradient(to left, rgb(0, 0, 128) 0%, rgb(16, 132, 208) 100%);
	background: linear-gradient(to left, var(--ActiveTitle) 0%, var(--GradientActiveTitle) 100%);
}
.os-window:not(.tool-window) .window-titlebar,
body > .window-titlebar {
	font-weight: bold;
}
.os-window:not(.focused) .window-titlebar {
	background: darkgray;
	background: linear-gradient(to right, rgb(128, 128, 128) 0%, rgb(181, 181, 181) 100%);
	background: linear-gradient(to right, var(--InactiveTitle) 0%, var(--GradientInactiveTitle) 100%);

	color: rgb(192, 192, 192);

	color: var(--InactiveTitleText);
}
.os-window.rtl:not(.focused) .window-titlebar {
	background: linear-gradient(to left, rgb(128, 128, 128) 0%, rgb(181, 181, 181) 100%);
	background: linear-gradient(to left, var(--InactiveTitle) 0%, var(--GradientInactiveTitle) 100%);
}
.os-window {
	/* Needed for when maximized, otherwise would be provided by %outset-deep */
	background: rgb(192, 192, 192);
	background: var(--ButtonFace);

	/* background: var(--Window); */
	/*color: var(--WindowText);*/
	/*border: 1px solid var(--WindowFrame);*/
	/* TODO: use window-specific theme colors; also different types of windows */
}
.os-window:not(.maximized) {
	border-style: solid;
	border-width: 1px;
	border-color: rgb(255, 255, 255) rgb(128, 128, 128) rgb(128, 128, 128) rgb(255, 255, 255);
	border-color: var(--ButtonHilight) var(--ButtonShadow) var(--ButtonShadow) var(--ButtonHilight);
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	color: rgb(0, 0, 0);
	color: var(--ButtonText);
	/* as fallback */
	position: relative;
	/* for pseudo element(s) */
	-o-border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	   border-image: url("data:image/svg+xml,%3Csvg%20version%3D%221.1%22%20xmlns%3D%22http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg%22%20width%3D%22256px%22%20height%3D%22256px%22%20viewBox%3D%220%200%20256%20256%22%3E%0A%09%09%09%0A%09%09%3Cpath%20d%3D%22M0%200h224v32h-192v192h-32v-224z%22%20fill%3D%22%20rgb(255%2C%20255%2C%20255)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M224%200h32v256h-256v-32h224v-224z%22%20fill%3D%22%20rgb(0%2C%200%2C%200)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M32%2032h160v32h-128v128h-32v-160z%22%20fill%3D%22%20rgb(223%2C%20223%2C%20223)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M192%2032h32v192h-192v-32h160v-160z%22%20fill%3D%22%20rgb(128%2C%20128%2C%20128)%22%2F%3E%0A%09%09%3Cpath%20d%3D%22M64%2064h128v128h-128v-128z%22%20fill%3D%22%20rgb(192%2C%20192%2C%20192)%22%2F%3E%0A%09%0A%09%09%3C%2Fsvg%3E") 64 / 2px;
	-o-border-image: var(--button-normal-border-image);
	   border-image: var(--button-normal-border-image);
	border-color: rgb(223, 223, 223) rgb(128, 128, 128) rgb(128, 128, 128) rgb(223, 223, 223);
	border-color: var(--ButtonLight) var(--ButtonShadow) var(--ButtonShadow) var(--ButtonLight);
	border-style: solid;
	border-width: 2px 2px;
	padding: 2px;
}

.window-button {
	display: block;
	width: 16px;
	height: 14px;
	padding: 0;
	margin: 2px 0;
}
.window-button-icon {
	display: block;
	/* background-image: url("images/titlebar-buttons.png"); */
	--sprite-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAAKCAYAAADo3z3CAAAAoUlEQVRIS9VVWw7AIAib9z/0FpZgCOFRgpluf9MClhYdV++7gfDhYLxYDw+UyiHd5F8S5lr6zNa6Xpv/KwhHOahQpLB1+CwfycgYrwmE0WK8MTsIR1aOGsR+NYkkYzN5/pGwVA9xA/diq8LeHCKuQxQ+aoYt2yJWtpSNZth0edRpGVC5eGQcSg4hXLml3fdpBeHs8evWyPKX9ruXVqnYCeAHA8IyC9K2kmkAAAAASUVORK5CYII=");
	--sprite-y: 0;
	-ms-interpolation-mode: nearest-neighbor;
	    image-rendering: -moz-crisp-edges;
	    image-rendering: pixelated;
	width: 12px;
	height: 10px;
	position: relative;
	pointer-events: none;
}
.os-window .window-button:enabled:hover:active .window-button-icon,
.os-window .window-button.pressing .window-button-icon {
	top: 1px;
	left: 1px;
}
.window-button:disabled .window-button-icon {
	/* filter: saturate(0%) opacity(50%); fallback */
	/* filter: url("#os-gui-black-to-inset-filter"); */
}
.window-button .window-button-icon::before,
.window-button .window-button-icon::after {
	content: "";
	display: block;
	position: absolute;
	left: 0;
	top: 0;
	right: 0;
	bottom: 0;
	-webkit-mask-image: var(--sprite-image);
	        mask-image: var(--sprite-image);
	-webkit-mask-position: var(--sprite-x) var(--sprite-y);
	        mask-position: var(--sprite-x) var(--sprite-y);
	background-color: rgb(0, 0, 0);
	background-color: var(--ButtonText);
}
.window-button:disabled .window-button-icon::before {
	background-color: rgb(255, 255, 255);
	background-color: var(--ButtonHilight);
	left: 1px;
	top: 1px;
}
.window-button:enabled .window-button-icon::after {
	display: none;
}
.window-button:disabled .window-button-icon::after {
	background-color: rgb(128, 128, 128);
	background-color: var(--GrayText);
}
.window-action-close .window-button-icon  {
	--sprite-x: calc(-3 * 13px - 1px);
}
.window-action-maximize .window-button-icon  {
	--sprite-x: calc(-1 * 13px - 1px);
}
.window-action-restore .window-button-icon  {
	--sprite-x: calc(-2 * 13px - 1px);
}
.window-action-minimize .window-button-icon  {
	--sprite-x: calc(-0 * 13px - 1px);
}
.window-close-button {
	margin-left: 2px;
	margin-right: 2px;
}
.os-window.tool-window .window-close-button {
	width: 11px;
	height: 11px;
}
.os-window.tool-window .window-close-button .window-button-icon {
	width: 7px;
	height: 7px;
	--sprite-x: 7px;
}
.os-window .window-title-area {
	height: 16px;
}
.os-window.tool-window .window-title-area {
	height: 14px;
}
.os-window .window-titlebar {
	height: 18px;
}
.os-window.tool-window .window-titlebar {
	height: 15px;
}
.os-window .window-title {
	position: absolute;
	left: 0;
	top: 0;
	right: 0;
	bottom: 0;
	display: inline-block !important;
	margin: 0;
	padding: 0;
	overflow: hidden;
	text-overflow: ellipsis;
	white-space: nowrap;
	padding-left: 2px;
}

.menus {
	background: rgb(192, 192, 192);
	background: var(--Menu);
	color: rgb(0, 0, 0);
	color: var(--MenuText);
}
.os-window:not(.focused) .menus {
	color: rgb(128, 128, 128);
	color: var(--GrayText);
}
.menus *, .menu-popup * {
	font-family: 'Segoe UI', sans-serif;
	font-size: 12px;
}
.menu-button {
	box-sizing: border-box;
	height: 18px;
	line-height: 1;
	margin-top: 1px;
	margin-bottom: 1px;
	padding: 2px 5px;
	position: relative;
	outline: 0;
	/* @extend button.lightweight; */
	background: rgb(192, 192, 192);
	background: var(--Menu);
}
/* Note: In Windows 98, normal menu bars have an inset highlight if you use Esc and then the arrow keys,
whereas Explorer's menu bars are outset and match the hover effect, which I feel makes more sense,
so I think I'll immitate that. */
/* Also, to prevent duplicate highlight, and lingering highlight with touch, I'm using a class, rather than :hover/:focus/:active */
.menu-button.highlight {
	box-shadow: 1px 1px 0 rgb(255, 255, 255) inset, -1px -1px 0 rgb(128, 128, 128) inset;
	box-shadow: 1px 1px 0 var(--ButtonHilight) inset, -1px -1px 0 var(--ButtonShadow) inset;
}
.menu-button.highlight.active {
	box-shadow: 1px 1px 0 rgb(128, 128, 128) inset, -1px -1px 0 rgb(255, 255, 255) inset;
	box-shadow: 1px 1px 0 var(--ButtonShadow) inset, -1px -1px 0 var(--ButtonHilight) inset;
	top: 1px;
	left: 1px;
}
.menu-popup {
	display: block;
	padding: 2px;
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	border-top: 1px solid rgb(192, 192, 192);
	border-top: 1px solid var(--ButtonFace);
	border-left: 1px solid rgb(192, 192, 192);
	border-left: 1px solid var(--ButtonFace);
	border-right: 1px solid rgb(0, 0, 0);
	border-right: 1px solid var(--ButtonDkShadow);
	border-bottom: 1px solid rgb(0, 0, 0);
	border-bottom: 1px solid var(--ButtonDkShadow);
	box-shadow: 1px 1px 0 rgb(255, 255, 255) inset, -1px -1px 0 rgb(128, 128, 128) inset;
	box-shadow: 1px 1px 0 var(--ButtonHilight) inset, -1px -1px 0 var(--ButtonShadow) inset;
	background: rgb(192, 192, 192);
	background: var(--Menu);
	color: rgb(0, 0, 0);
	color: var(--MenuText);
}
.menu-popup td {
    padding: 0 1px;
}
.menu-item {
	padding: 1px 3px;
	margin: 2px;
	height: 17px;
}
.menu-item[disabled] {
	color: rgb(128, 128, 128);
	color: var(--GrayText);
	text-shadow: 0.8px 0.8px 0px rgb(255, 255, 255);
	text-shadow: 0.8px 0.8px 0px var(--ButtonHilight);
}
.menu-item.highlight:not([disabled]),
.menu-item.active:not([disabled]) {
	color: rgb(255, 255, 255);
	color: var(--HilightText);
}
.menu-item.highlight,
.menu-item.active {
	background: rgb(0, 0, 128);
	background: var(--Hilight);
	text-shadow: none;
	outline: 0;
}
.menu-item .menu-item-shortcut {
	padding-left: 10px;
}
.menu-hr {
	border: 0;
	border-top: 1px solid rgb(128, 128, 128);
	border-top: 1px solid var(--ButtonShadow);
	border-bottom: 1px solid rgb(255, 255, 255);
	border-bottom: 1px solid var(--ButtonHilight);
	margin: 0;
	margin-top: 3px;
	margin-bottom: 4px;
}
.menu-hotkey {
	text-decoration: underline;
}
.menu-hotkey::-moz-selection {
	/* prevent weird looking white underlines if menubar is contained in a selection, possible in the demo (minute edge case) */
    text-decoration-color: rgb(0, 0, 0) !important;
    text-decoration-color: var(--MenuText) !important;
}
.menu-hotkey::selection {
	/* prevent weird looking white underlines if menubar is contained in a selection, possible in the demo (minute edge case) */
    -webkit-text-decoration-color: rgb(0, 0, 0) !important;
            text-decoration-color: rgb(0, 0, 0) !important;
    -webkit-text-decoration-color: var(--MenuText) !important;
            text-decoration-color: var(--MenuText) !important;
}


::-moz-selection {
	background-color: rgb(0, 0, 128);
	background-color: var(--Hilight);
	color: rgb(255, 255, 255);
	color: var(--HilightText);
}


::selection {
	background-color: rgb(0, 0, 128);
	background-color: var(--Hilight);
	color: rgb(255, 255, 255);
	color: var(--HilightText);
}

.scrollbar {
	background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAG0lEQVQYV2P8/////4MHDzIwHjhw4L+9vT0DAHAFCj6esq3FAAAAAElFTkSuQmCC") repeat;
	background: var(--checker) repeat;
	-ms-interpolation-mode: nearest-neighbor;
	    image-rendering: -moz-crisp-edges;
	    image-rendering: pixelated;
}
.scrollbar-thumb {
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	border-top: 1px solid rgb(192, 192, 192);
	border-top: 1px solid var(--ButtonFace);
	border-left: 1px solid rgb(192, 192, 192);
	border-left: 1px solid var(--ButtonFace);
	border-right: 1px solid rgb(0, 0, 0);
	border-right: 1px solid var(--ButtonDkShadow);
	border-bottom: 1px solid rgb(0, 0, 0);
	border-bottom: 1px solid var(--ButtonDkShadow);
	box-shadow: 1px 1px 0 rgb(255, 255, 255) inset, -1px -1px 0 rgb(128, 128, 128) inset;
	box-shadow: 1px 1px 0 var(--ButtonHilight) inset, -1px -1px 0 var(--ButtonShadow) inset;
}
.scrollbar-track-piece:hover:active {
	background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAG0lEQVQYV2P8/////4MHDzIwHjhw4L+9vT0DAHAFCj6esq3FAAAAAElFTkSuQmCC") repeat;
	background: var(--checker) repeat;
	-ms-interpolation-mode: nearest-neighbor;
	    image-rendering: -moz-crisp-edges;
	    image-rendering: pixelated;
	background-color: white;
	background-blend-mode: difference;
	/* background-attachment: fixed; breaks the checkered background in chrome */
}
.scrollbar-track-piece.increment {
	background-position: bottom;
}
.scrollbar-corner {
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
}

.scrollbar-button {
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	border-top: 1px solid rgb(192, 192, 192);
	border-top: 1px solid var(--ButtonFace);
	border-left: 1px solid rgb(192, 192, 192);
	border-left: 1px solid var(--ButtonFace);
	border-right: 1px solid rgb(0, 0, 0);
	border-right: 1px solid var(--ButtonDkShadow);
	border-bottom: 1px solid rgb(0, 0, 0);
	border-bottom: 1px solid var(--ButtonDkShadow);
	box-shadow: 1px 1px 0 rgb(255, 255, 255) inset, -1px -1px 0 rgb(128, 128, 128) inset;
	box-shadow: 1px 1px 0 var(--ButtonHilight) inset, -1px -1px 0 var(--ButtonShadow) inset;
	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAJCAYAAABaMo5wAAAAW0lEQVQ4T2NkGGSAcZC5h4FWDvrPwEC02ShqkR0EkkAHuBxMyEKYWYQ8jKEOXQOyo/A5BuZwqqvBZiA+3xMbilQLIWqlcUJRimwPzjRELcdQZA6hREeR4eRoBgBoXhAK6oiMhwAAAABJRU5ErkJggg==");
	background-image: var(--scrollbar-arrows-ButtonText);
	-ms-interpolation-mode: nearest-neighbor;
	    image-rendering: -moz-crisp-edges;
	    image-rendering: pixelated;
	width: 13px;
	width: var(--scrollbar-size);
	height: 13px;
	height: var(--scrollbar-size);
	box-sizing: border-box;
}
.scrollbar-button:not(.disabled):hover:active {
	border: 1px solid rgb(128, 128, 128);
	border: 1px solid var(--ButtonShadow);
	box-shadow: none;
}
.scrollbar-button.disabled {
	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAJCAYAAABaMo5wAAAAYElEQVQ4T2NkGGSAcZC5h4EmDmpoaPjf0NBAlNnoauGaQBLooYXLUEIWwswi5Chs6lB8gewofI6BOZwWajCCFZ/viQ1FqoUQtRI4oShFtgdnGqKWYyg1h6icQKklpOgHAM9mQArEvm5+AAAAAElFTkSuQmCC"), url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAJCAYAAABaMo5wAAAAYElEQVQ4T2NkGGSAcZC5h4EmDvr///9/RkZGosxGVwvXBJJADy1chhKyEGYWIUdhU4fiC2RH4XMMzOG0UIMRrPh8T2woUi2EqJXACUUpsj040xC1HEOpOUTlBEotIUU/AKXFQAqyTJ6DAAAAAElFTkSuQmCC");
	background-image: var(--scrollbar-arrows-GrayText), var(--scrollbar-arrows-ButtonHilight);
}

.scrollbar-button.horizontal.decrement.disabled {
	background-position: /* left arrow */
		calc(9px * -3 + 1px) 1px,
		calc(9px * -3 + 2px) 2px;
	background-position: /* left arrow */
		calc(var(--scrollbar-button-inner-size) * -3 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -3 + 2px) 2px;
}
.scrollbar-button.horizontal.increment.disabled {
	background-position: /* right arrow */
		calc(9px * -2 + 1px) 1px,
		calc(9px * -2 + 2px) 2px;
	background-position: /* right arrow */
		calc(var(--scrollbar-button-inner-size) * -2 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -2 + 2px) 2px;
}
.scrollbar-button.vertical.decrement.disabled {
	background-position: /* up arrow */
		calc(9px * -1 + 1px) 1px,
		calc(9px * -1 + 2px) 2px;
	background-position: /* up arrow */
		calc(var(--scrollbar-button-inner-size) * -1 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -1 + 2px) 2px;
}
.scrollbar-button.vertical.increment.disabled {
	background-position: /* down arrow */
		calc(9px * -0 + 1px) 1px,
		calc(9px * -0 + 2px) 2px;
	background-position: /* down arrow */
		calc(var(--scrollbar-button-inner-size) * -0 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -0 + 2px) 2px;
}

.scrollbar-button.horizontal.decrement {
	background-position: calc(9px * -3 + 1px) 1px;
	background-position: calc(var(--scrollbar-button-inner-size) * -3 + 1px) 1px; /* left */
}
.scrollbar-button.horizontal.increment {
	background-position: calc(9px * -2 + 1px) 1px;
	background-position: calc(var(--scrollbar-button-inner-size) * -2 + 1px) 1px; /* right */
}
.scrollbar-button.vertical.decrement {
	background-position: calc(9px * -1 + 1px) 1px;
	background-position: calc(var(--scrollbar-button-inner-size) * -1 + 1px) 1px; /* up */
}
.scrollbar-button.vertical.increment {
	background-position: calc(9px * -0 + 1px) 1px;
	background-position: calc(var(--scrollbar-button-inner-size) * -0 + 1px) 1px; /* down */
}

::-webkit-scrollbar,
::-webkit-scrollbar-thumb,
::-webkit-scrollbar-button {
	width: 13px;
	width: var(--scrollbar-size);
	height: 13px;
	height: var(--scrollbar-size);
}

::-webkit-scrollbar {
	background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAG0lEQVQYV2P8/////4MHDzIwHjhw4L+9vT0DAHAFCj6esq3FAAAAAElFTkSuQmCC") repeat;
	background: var(--checker) repeat;
	image-rendering: pixelated;
}
::-webkit-scrollbar-thumb {
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	border-top: 1px solid rgb(192, 192, 192);
	border-top: 1px solid var(--ButtonFace);
	border-left: 1px solid rgb(192, 192, 192);
	border-left: 1px solid var(--ButtonFace);
	border-right: 1px solid rgb(0, 0, 0);
	border-right: 1px solid var(--ButtonDkShadow);
	border-bottom: 1px solid rgb(0, 0, 0);
	border-bottom: 1px solid var(--ButtonDkShadow);
	box-shadow: 1px 1px 0 rgb(255, 255, 255) inset, -1px -1px 0 rgb(128, 128, 128) inset;
	box-shadow: 1px 1px 0 var(--ButtonHilight) inset, -1px -1px 0 var(--ButtonShadow) inset;
}
::-webkit-scrollbar-corner {
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
}

::-webkit-scrollbar-button {
	background-color: rgb(192, 192, 192);
	background-color: var(--ButtonFace);
	border-top: 1px solid rgb(192, 192, 192);
	border-top: 1px solid var(--ButtonFace);
	border-left: 1px solid rgb(192, 192, 192);
	border-left: 1px solid var(--ButtonFace);
	border-right: 1px solid rgb(0, 0, 0);
	border-right: 1px solid var(--ButtonDkShadow);
	border-bottom: 1px solid rgb(0, 0, 0);
	border-bottom: 1px solid var(--ButtonDkShadow);
	box-shadow: 1px 1px 0 rgb(255, 255, 255) inset, -1px -1px 0 rgb(128, 128, 128) inset;
	box-shadow: 1px 1px 0 var(--ButtonHilight) inset, -1px -1px 0 var(--ButtonShadow) inset;
	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAJCAYAAABaMo5wAAAAW0lEQVQ4T2NkGGSAcZC5h4FWDvrPwEC02ShqkR0EkkAHuBxMyEKYWYQ8jKEOXQOyo/A5BuZwqqvBZiA+3xMbilQLIWqlcUJRimwPzjRELcdQZA6hREeR4eRoBgBoXhAK6oiMhwAAAABJRU5ErkJggg==");
	background-image: var(--scrollbar-arrows-ButtonText);
	image-rendering: pixelated;
	width: 13px;
	width: var(--scrollbar-size);
	height: 13px;
	height: var(--scrollbar-size);
	box-sizing: border-box;
}

::-webkit-scrollbar-button:not(.disabled):hover:active {
	border: 1px solid rgb(128, 128, 128);
	border: 1px solid var(--ButtonShadow);
	box-shadow: none;
}

::-webkit-scrollbar-button.disabled {
	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAJCAYAAABaMo5wAAAAYElEQVQ4T2NkGGSAcZC5h4EmDmpoaPjf0NBAlNnoauGaQBLooYXLUEIWwswi5Chs6lB8gewofI6BOZwWajCCFZ/viQ1FqoUQtRI4oShFtgdnGqKWYyg1h6icQKklpOgHAM9mQArEvm5+AAAAAElFTkSuQmCC"), url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAJCAYAAABaMo5wAAAAYElEQVQ4T2NkGGSAcZC5h4EmDvr///9/RkZGosxGVwvXBJJADy1chhKyEGYWIUdhU4fiC2RH4XMMzOG0UIMRrPh8T2woUi2EqJXACUUpsj040xC1HEOpOUTlBEotIUU/AKXFQAqyTJ6DAAAAAElFTkSuQmCC");
	background-image: var(--scrollbar-arrows-GrayText), var(--scrollbar-arrows-ButtonHilight);
}

::-webkit-scrollbar-button.horizontal.decrement.disabled {
	background-position: /* left arrow */
		calc(9px * -3 + 1px) 1px,
		calc(9px * -3 + 2px) 2px;
	background-position: /* left arrow */
		calc(var(--scrollbar-button-inner-size) * -3 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -3 + 2px) 2px;
}

::-webkit-scrollbar-button.horizontal.increment.disabled {
	background-position: /* right arrow */
		calc(9px * -2 + 1px) 1px,
		calc(9px * -2 + 2px) 2px;
	background-position: /* right arrow */
		calc(var(--scrollbar-button-inner-size) * -2 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -2 + 2px) 2px;
}

::-webkit-scrollbar-button.vertical.decrement.disabled {
	background-position: /* up arrow */
		calc(9px * -1 + 1px) 1px,
		calc(9px * -1 + 2px) 2px;
	background-position: /* up arrow */
		calc(var(--scrollbar-button-inner-size) * -1 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -1 + 2px) 2px;
}

::-webkit-scrollbar-button.vertical.increment.disabled {
	background-position: /* down arrow */
		calc(9px * -0 + 1px) 1px,
		calc(9px * -0 + 2px) 2px;
	background-position: /* down arrow */
		calc(var(--scrollbar-button-inner-size) * -0 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -0 + 2px) 2px;
}

::-webkit-scrollbar-button.horizontal.decrement {
	background-position: calc(9px * -3 + 1px) 1px;
	background-position: calc(var(--scrollbar-button-inner-size) * -3 + 1px) 1px;
	/* left */
}

::-webkit-scrollbar-button.horizontal.increment {
	background-position: calc(9px * -2 + 1px) 1px;
	background-position: calc(var(--scrollbar-button-inner-size) * -2 + 1px) 1px;
	/* right */
}

::-webkit-scrollbar-button.vertical.decrement {
	background-position: calc(9px * -1 + 1px) 1px;
	background-position: calc(var(--scrollbar-button-inner-size) * -1 + 1px) 1px;
	/* up */
}

::-webkit-scrollbar-button.vertical.increment {
	background-position: calc(9px * -0 + 1px) 1px;
	background-position: calc(var(--scrollbar-button-inner-size) * -0 + 1px) 1px;
	/* down */
}
::-webkit-scrollbar-button:hover:active {
	border: 1px solid rgb(128, 128, 128);
	border: 1px solid var(--ButtonShadow);
	box-shadow: none;
}
::-webkit-scrollbar-button:disabled {
	background-image: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAJCAYAAABaMo5wAAAAYElEQVQ4T2NkGGSAcZC5h4EmDmpoaPjf0NBAlNnoauGaQBLooYXLUEIWwswi5Chs6lB8gewofI6BOZwWajCCFZ/viQ1FqoUQtRI4oShFtgdnGqKWYyg1h6icQKklpOgHAM9mQArEvm5+AAAAAElFTkSuQmCC"), url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACQAAAAJCAYAAABaMo5wAAAAYElEQVQ4T2NkGGSAcZC5h4EmDvr///9/RkZGosxGVwvXBJJADy1chhKyEGYWIUdhU4fiC2RH4XMMzOG0UIMRrPh8T2woUi2EqJXACUUpsj040xC1HEOpOUTlBEotIUU/AKXFQAqyTJ6DAAAAAElFTkSuQmCC");
	background-image: var(--scrollbar-arrows-GrayText), var(--scrollbar-arrows-ButtonHilight);
}

::-webkit-scrollbar-button:horizontal:decrement:disabled {
	background-position: /* left arrow */
		calc(9px * -3 + 1px) 1px,
		calc(9px * -3 + 2px) 2px;
	background-position: /* left arrow */
		calc(var(--scrollbar-button-inner-size) * -3 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -3 + 2px) 2px;
}
::-webkit-scrollbar-button:horizontal:increment:disabled {
	background-position: /* right arrow */
		calc(9px * -2 + 1px) 1px,
		calc(9px * -2 + 2px) 2px;
	background-position: /* right arrow */
		calc(var(--scrollbar-button-inner-size) * -2 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -2 + 2px) 2px;
}
::-webkit-scrollbar-button:vertical:decrement:disabled {
	background-position: /* up arrow */
		calc(9px * -1 + 1px) 1px,
		calc(9px * -1 + 2px) 2px;
	background-position: /* up arrow */
		calc(var(--scrollbar-button-inner-size) * -1 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -1 + 2px) 2px;
}
::-webkit-scrollbar-button:vertical:increment:disabled {
	background-position: /* down arrow */
		calc(9px * -0 + 1px) 1px,
		calc(9px * -0 + 2px) 2px;
	background-position: /* down arrow */
		calc(var(--scrollbar-button-inner-size) * -0 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -0 + 2px) 2px;
}

::-webkit-scrollbar-button:horizontal:decrement.disabled {
	background-position: /* left arrow */
		calc(9px * -3 + 1px) 1px,
		calc(9px * -3 + 2px) 2px;
	background-position: /* left arrow */
		calc(var(--scrollbar-button-inner-size) * -3 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -3 + 2px) 2px;
}

::-webkit-scrollbar-button:horizontal:decrement {
	background-position: calc(9px * -3 + 1px) 1px;
	background-position: calc(var(--scrollbar-button-inner-size) * -3 + 1px) 1px;
	/* left */
}
::-webkit-scrollbar-button:horizontal:increment.disabled {
	background-position: /* right arrow */
		calc(9px * -2 + 1px) 1px,
		calc(9px * -2 + 2px) 2px;
	background-position: /* right arrow */
		calc(var(--scrollbar-button-inner-size) * -2 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -2 + 2px) 2px;
}
::-webkit-scrollbar-button:horizontal:increment {
	background-position: calc(9px * -2 + 1px) 1px;
	background-position: calc(var(--scrollbar-button-inner-size) * -2 + 1px) 1px;
	/* right */
}
::-webkit-scrollbar-button:vertical:decrement.disabled {
	background-position: /* up arrow */
		calc(9px * -1 + 1px) 1px,
		calc(9px * -1 + 2px) 2px;
	background-position: /* up arrow */
		calc(var(--scrollbar-button-inner-size) * -1 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -1 + 2px) 2px;
}
::-webkit-scrollbar-button:vertical:decrement {
	background-position: calc(9px * -1 + 1px) 1px;
	background-position: calc(var(--scrollbar-button-inner-size) * -1 + 1px) 1px;
	/* up */
}
::-webkit-scrollbar-button:vertical:increment.disabled {
	background-position: /* down arrow */
		calc(9px * -0 + 1px) 1px,
		calc(9px * -0 + 2px) 2px;
	background-position: /* down arrow */
		calc(var(--scrollbar-button-inner-size) * -0 + 1px) 1px,
		calc(var(--scrollbar-button-inner-size) * -0 + 2px) 2px;
}
::-webkit-scrollbar-button:vertical:increment {
	background-position: calc(9px * -0 + 1px) 1px;
	background-position: calc(var(--scrollbar-button-inner-size) * -0 + 1px) 1px;
	/* down */
}

::-webkit-scrollbar-track-piece:hover:active {
	background: url("data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAIAAAACCAYAAABytg0kAAAAG0lEQVQYV2P8/////4MHDzIwHjhw4L+9vT0DAHAFCj6esq3FAAAAAElFTkSuQmCC") repeat;
	background: var(--checker) repeat;
	image-rendering: pixelated;
	background-color: white;
	background-blend-mode: difference;
	/* background-attachment: fixed; breaks the checkered background in chrome */
}

::-webkit-scrollbar-track-piece.increment {
	background-position: bottom;
}
::-webkit-scrollbar-track-piece:increment {
	background-position: bottom;
}

/* turn off double buttons */
::-webkit-scrollbar-button:start:increment,
::-webkit-scrollbar-button:end:decrement {
	display: none;
}

/*# sourceMappingURL=windows-98.css.map */</style>
<style>
html,
body {
    width: 100%;
    height: 100%;
    margin: 0;
    padding: 0;
}

html,
body,
.solitaire,
.size-limit {
    display: flex;
    flex: 1;
    flex-direction: column;
}

.solitaire {
    width: 100%;
    height: 100%;
    box-sizing: border-box;
    background-color: green;
    position: relative;
    overflow: hidden; /* important for win effect */
    touch-action: none;
    -webkit-touch-callout: none;
    -webkit-user-select: none;
    user-select: none;

    --card-width: 71px;
    --card-height: 96px;
}

.size-limit {
    --max-width: 1200px;
    max-width: var(--max-width);
    margin-left: max(calc(50vw - var(--max-width) / 2), 0px);
}

.card {
    width: var(--card-width);
    height: var(--card-height);
    background-image: url("./spritesheet.png");
    position: absolute;
    left: 0;
    top: 0;
    user-select: none;
}
.card--back {
    background-position: var(--background-position-facing-down);
}
.card--front {
    cursor: pointer;
    background-position: var(--background-position-facing-up);
}
.card--moving {
    position: fixed;
    z-index: 1;
}

.deck__pile {
    flex-shrink: 0; /* for small viewport */
    position: relative;
    width: var(--card-width);
    height: var(--card-height);
    cursor: pointer;
    background-image: url("./spritesheet.png");
    background-position: calc(var(--card-width) * -1) calc(var(--card-height) * -5);
}
.deck__pile .card + .card {
    margin-top: 1px;
    margin-left: 2px;
}
.deck__pile .card + .card + .card {
    margin-left: 4px;
    margin-top: 2px;
}
.deck__deal {
    position: relative;
}
.deck__deal .card:last-child:not(:first-child) {
    left: 28px;
    top: 2px;
}
.deck__deal .card:nth-last-child(2):not(:first-child) {
    left: 14px;
    top: 1px;
}
.deck__deal .card:first-child + .card:last-child {
    left: 14px;
    top: 1px;
}

.finish-deck {
    flex: 4;
    display: flex;
    justify-content: center;
}

.upper {
    display: flex;
    padding-top: 5px;
    justify-content: space-evenly;
}
.upper__spacer {
    width: var(--card-width);
}
.board-deck {
    display: flex;
    padding-top: 6px;
    justify-content: space-evenly;
}
.board-deck .card--front > .card--front {
    top: 15px;
}
.board-deck .card--back > .card--front,
.board-deck .card--back > .card--back {
    top: 3px;
}

/* card cells */
.seven,
.aces {
    position: relative;
    width: var(--card-width);
    height: var(--card-height);
    background-image: url("./spritesheet.png");
    background-position: calc(var(--card-width) * -0) calc(var(--card-height) * -4);
}

.finish-dest {
    box-shadow: 0 0 0 1px #03ffff;
    border-radius: 4px;
}
</style>
<link href="img/solitaire-16x16.png" rel="icon" sizes="16x16" type="image/png"/>
<link href="img/solitaire-32x32.png" rel="icon" sizes="32x32" type="image/png"/>
<title>Solitaire  Unblocked - ClassRoom6x</title>
<meta content="classroom6x.gitlab.io" name="website">
</meta></head>
<body style="overflow:hidden;">
<div class="solitaire inset-deep" id="js-solitaire">
<div class="size-limit">
<div class="upper" id="js-upper">
<div class="deck__pile upper__spacer" id="js-deck-pile"></div>
<div class="deck__deal upper__spacer" id="js-deck-deal"></div>
<div class="upper__spacer"></div>
</div>
<div class="board-deck" id="js-board"></div>
</div>
</div>
<script>/*! jQuery v2.1.1 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */
!function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m="2.1.1",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)>=0},isPlainObject:function(a){return"object"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=l.createElement("script"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+-new Date,v=a.document,w=0,x=0,y=gb(),z=gb(),A=gb(),B=function(a,b){return a===b&&(l=!0),0},C="undefined",D=1<<31,E={}.hasOwnProperty,F=[],G=F.pop,H=F.push,I=F.push,J=F.slice,K=F.indexOf||function(a){for(var b=0,c=this.length;c>b;b++)if(this[b]===a)return b;return-1},L="checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",M="[\\x20\\t\\r\\n\\f]",N="(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",O=N.replace("w","w#"),P="\\["+M+"*("+N+")(?:"+M+"*([*^$|!~]?=)"+M+"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|("+O+"))|)"+M+"*\\]",Q=":("+N+")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|"+P+")*)|.*)\\)|)",R=new RegExp("^"+M+"+|((?:^|[^\\\\])(?:\\\\.)*)"+M+"+$","g"),S=new RegExp("^"+M+"*,"+M+"*"),T=new RegExp("^"+M+"*([>+~]|"+M+")"+M+"*"),U=new RegExp("="+M+"*([^\\]'\"]*?)"+M+"*\\]","g"),V=new RegExp(Q),W=new RegExp("^"+O+"$"),X={ID:new RegExp("^#("+N+")"),CLASS:new RegExp("^\\.("+N+")"),TAG:new RegExp("^("+N.replace("w","w*")+")"),ATTR:new RegExp("^"+P),PSEUDO:new RegExp("^"+Q),CHILD:new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\("+M+"*(even|odd|(([+-]|)(\\d*)n|)"+M+"*(?:([+-]|)"+M+"*(\\d+)|))"+M+"*\\)|)","i"),bool:new RegExp("^(?:"+L+")$","i"),needsContext:new RegExp("^"+M+"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\("+M+"*((?:-\\d)?\\d*)"+M+"*\\)|)(?=[^-]|$)","i")},Y=/^(?:input|select|textarea|button)$/i,Z=/^h\d$/i,$=/^[^{]+\{\s*\[native \w/,_=/^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,ab=/[+~]/,bb=/'|\\/g,cb=new RegExp("\\\\([\\da-f]{1,6}"+M+"?|("+M+")|.)","ig"),db=function(a,b,c){var d="0x"+b-65536;return d!==d||c?b:0>d?String.fromCharCode(d+65536):String.fromCharCode(d>>10|55296,1023&d|56320)};try{I.apply(F=J.call(v.childNodes),v.childNodes),F[v.childNodes.length].nodeType}catch(eb){I={apply:F.length?function(a,b){H.apply(a,J.call(b))}:function(a,b){var c=a.length,d=0;while(a[c++]=b[d++]);a.length=c-1}}}function fb(a,b,d,e){var f,h,j,k,l,o,r,s,w,x;if((b?b.ownerDocument||b:v)!==n&&m(b),b=b||n,d=d||[],!a||"string"!=typeof a)return d;if(1!==(k=b.nodeType)&&9!==k)return[];if(p&&!e){if(f=_.exec(a))if(j=f[1]){if(9===k){if(h=b.getElementById(j),!h||!h.parentNode)return d;if(h.id===j)return d.push(h),d}else if(b.ownerDocument&&(h=b.ownerDocument.getElementById(j))&&t(b,h)&&h.id===j)return d.push(h),d}else{if(f[2])return I.apply(d,b.getElementsByTagName(a)),d;if((j=f[3])&&c.getElementsByClassName&&b.getElementsByClassName)return I.apply(d,b.getElementsByClassName(j)),d}if(c.qsa&&(!q||!q.test(a))){if(s=r=u,w=b,x=9===k&&a,1===k&&"object"!==b.nodeName.toLowerCase()){o=g(a),(r=b.getAttribute("id"))?s=r.replace(bb,"\\$&"):b.setAttribute("id",s),s="[id='"+s+"'] ",l=o.length;while(l--)o[l]=s+qb(o[l]);w=ab.test(a)&&ob(b.parentNode)||b,x=o.join(",")}if(x)try{return I.apply(d,w.querySelectorAll(x)),d}catch(y){}finally{r||b.removeAttribute("id")}}}return i(a.replace(R,"$1"),b,d,e)}function gb(){var a=[];function b(c,e){return a.push(c+" ")>d.cacheLength&&delete b[a.shift()],b[c+" "]=e}return b}function hb(a){return a[u]=!0,a}function ib(a){var b=n.createElement("div");try{return!!a(b)}catch(c){return!1}finally{b.parentNode&&b.parentNode.removeChild(b),b=null}}function jb(a,b){var c=a.split("|"),e=a.length;while(e--)d.attrHandle[c[e]]=b}function kb(a,b){var c=b&&a,d=c&&1===a.nodeType&&1===b.nodeType&&(~b.sourceIndex||D)-(~a.sourceIndex||D);if(d)return d;if(c)while(c=c.nextSibling)if(c===b)return-1;return a?1:-1}function lb(a){return function(b){var c=b.nodeName.toLowerCase();return"input"===c&&b.type===a}}function mb(a){return function(b){var c=b.nodeName.toLowerCase();return("input"===c||"button"===c)&&b.type===a}}function nb(a){return hb(function(b){return b=+b,hb(function(c,d){var e,f=a([],c.length,b),g=f.length;while(g--)c[e=f[g]]&&(c[e]=!(d[e]=c[e]))})})}function ob(a){return a&&typeof a.getElementsByTagName!==C&&a}c=fb.support={},f=fb.isXML=function(a){var b=a&&(a.ownerDocument||a).documentElement;return b?"HTML"!==b.nodeName:!1},m=fb.setDocument=function(a){var b,e=a?a.ownerDocument||a:v,g=e.defaultView;return e!==n&&9===e.nodeType&&e.documentElement?(n=e,o=e.documentElement,p=!f(e),g&&g!==g.top&&(g.addEventListener?g.addEventListener("unload",function(){m()},!1):g.attachEvent&&g.attachEvent("onunload",function(){m()})),c.attributes=ib(function(a){return a.className="i",!a.getAttribute("className")}),c.getElementsByTagName=ib(function(a){return a.appendChild(e.createComment("")),!a.getElementsByTagName("*").length}),c.getElementsByClassName=$.test(e.getElementsByClassName)&&ib(function(a){return a.innerHTML="<div class='a'></div><div class='a i'></div>",a.firstChild.className="i",2===a.getElementsByClassName("i").length}),c.getById=ib(function(a){return o.appendChild(a).id=u,!e.getElementsByName||!e.getElementsByName(u).length}),c.getById?(d.find.ID=function(a,b){if(typeof b.getElementById!==C&&p){var c=b.getElementById(a);return c&&c.parentNode?[c]:[]}},d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){return a.getAttribute("id")===b}}):(delete d.find.ID,d.filter.ID=function(a){var b=a.replace(cb,db);return function(a){var c=typeof a.getAttributeNode!==C&&a.getAttributeNode("id");return c&&c.value===b}}),d.find.TAG=c.getElementsByTagName?function(a,b){return typeof b.getElementsByTagName!==C?b.getElementsByTagName(a):void 0}:function(a,b){var c,d=[],e=0,f=b.getElementsByTagName(a);if("*"===a){while(c=f[e++])1===c.nodeType&&d.push(c);return d}return f},d.find.CLASS=c.getElementsByClassName&&function(a,b){return typeof b.getElementsByClassName!==C&&p?b.getElementsByClassName(a):void 0},r=[],q=[],(c.qsa=$.test(e.querySelectorAll))&&(ib(function(a){a.innerHTML="<select msallowclip=''><option selected=''></option></select>",a.querySelectorAll("[msallowclip^='']").length&&q.push("[*^$]="+M+"*(?:''|\"\")"),a.querySelectorAll("[selected]").length||q.push("\\["+M+"*(?:value|"+L+")"),a.querySelectorAll(":checked").length||q.push(":checked")}),ib(function(a){var b=e.createElement("input");b.setAttribute("type","hidden"),a.appendChild(b).setAttribute("name","D"),a.querySelectorAll("[name=d]").length&&q.push("name"+M+"*[*^$|!~]?="),a.querySelectorAll(":enabled").length||q.push(":enabled",":disabled"),a.querySelectorAll("*,:x"),q.push(",.*:")})),(c.matchesSelector=$.test(s=o.matches||o.webkitMatchesSelector||o.mozMatchesSelector||o.oMatchesSelector||o.msMatchesSelector))&&ib(function(a){c.disconnectedMatch=s.call(a,"div"),s.call(a,"[s!='']:x"),r.push("!=",Q)}),q=q.length&&new RegExp(q.join("|")),r=r.length&&new RegExp(r.join("|")),b=$.test(o.compareDocumentPosition),t=b||$.test(o.contains)?function(a,b){var c=9===a.nodeType?a.documentElement:a,d=b&&b.parentNode;return a===d||!(!d||1!==d.nodeType||!(c.contains?c.contains(d):a.compareDocumentPosition&&16&a.compareDocumentPosition(d)))}:function(a,b){if(b)while(b=b.parentNode)if(b===a)return!0;return!1},B=b?function(a,b){if(a===b)return l=!0,0;var d=!a.compareDocumentPosition-!b.compareDocumentPosition;return d?d:(d=(a.ownerDocument||a)===(b.ownerDocument||b)?a.compareDocumentPosition(b):1,1&d||!c.sortDetached&&b.compareDocumentPosition(a)===d?a===e||a.ownerDocument===v&&t(v,a)?-1:b===e||b.ownerDocument===v&&t(v,b)?1:k?K.call(k,a)-K.call(k,b):0:4&d?-1:1)}:function(a,b){if(a===b)return l=!0,0;var c,d=0,f=a.parentNode,g=b.parentNode,h=[a],i=[b];if(!f||!g)return a===e?-1:b===e?1:f?-1:g?1:k?K.call(k,a)-K.call(k,b):0;if(f===g)return kb(a,b);c=a;while(c=c.parentNode)h.unshift(c);c=b;while(c=c.parentNode)i.unshift(c);while(h[d]===i[d])d++;return d?kb(h[d],i[d]):h[d]===v?-1:i[d]===v?1:0},e):n},fb.matches=function(a,b){return fb(a,null,null,b)},fb.matchesSelector=function(a,b){if((a.ownerDocument||a)!==n&&m(a),b=b.replace(U,"='$1']"),!(!c.matchesSelector||!p||r&&r.test(b)||q&&q.test(b)))try{var d=s.call(a,b);if(d||c.disconnectedMatch||a.document&&11!==a.document.nodeType)return d}catch(e){}return fb(b,n,null,[a]).length>0},fb.contains=function(a,b){return(a.ownerDocument||a)!==n&&m(a),t(a,b)},fb.attr=function(a,b){(a.ownerDocument||a)!==n&&m(a);var e=d.attrHandle[b.toLowerCase()],f=e&&E.call(d.attrHandle,b.toLowerCase())?e(a,b,!p):void 0;return void 0!==f?f:c.attributes||!p?a.getAttribute(b):(f=a.getAttributeNode(b))&&f.specified?f.value:null},fb.error=function(a){throw new Error("Syntax error, unrecognized expression: "+a)},fb.uniqueSort=function(a){var b,d=[],e=0,f=0;if(l=!c.detectDuplicates,k=!c.sortStable&&a.slice(0),a.sort(B),l){while(b=a[f++])b===a[f]&&(e=d.push(f));while(e--)a.splice(d[e],1)}return k=null,a},e=fb.getText=function(a){var b,c="",d=0,f=a.nodeType;if(f){if(1===f||9===f||11===f){if("string"==typeof a.textContent)return a.textContent;for(a=a.firstChild;a;a=a.nextSibling)c+=e(a)}else if(3===f||4===f)return a.nodeValue}else while(b=a[d++])c+=e(b);return c},d=fb.selectors={cacheLength:50,createPseudo:hb,match:X,attrHandle:{},find:{},relative:{">":{dir:"parentNode",first:!0}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:!0},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(a){return a[1]=a[1].replace(cb,db),a[3]=(a[3]||a[4]||a[5]||"").replace(cb,db),"~="===a[2]&&(a[3]=" "+a[3]+" "),a.slice(0,4)},CHILD:function(a){return a[1]=a[1].toLowerCase(),"nth"===a[1].slice(0,3)?(a[3]||fb.error(a[0]),a[4]=+(a[4]?a[5]+(a[6]||1):2*("even"===a[3]||"odd"===a[3])),a[5]=+(a[7]+a[8]||"odd"===a[3])):a[3]&&fb.error(a[0]),a},PSEUDO:function(a){var b,c=!a[6]&&a[2];return X.CHILD.test(a[0])?null:(a[3]?a[2]=a[4]||a[5]||"":c&&V.test(c)&&(b=g(c,!0))&&(b=c.indexOf(")",c.length-b)-c.length)&&(a[0]=a[0].slice(0,b),a[2]=c.slice(0,b)),a.slice(0,3))}},filter:{TAG:function(a){var b=a.replace(cb,db).toLowerCase();return"*"===a?function(){return!0}:function(a){return a.nodeName&&a.nodeName.toLowerCase()===b}},CLASS:function(a){var b=y[a+" "];return b||(b=new RegExp("(^|"+M+")"+a+"("+M+"|$)"))&&y(a,function(a){return b.test("string"==typeof a.className&&a.className||typeof a.getAttribute!==C&&a.getAttribute("class")||"")})},ATTR:function(a,b,c){return function(d){var e=fb.attr(d,a);return null==e?"!="===b:b?(e+="","="===b?e===c:"!="===b?e!==c:"^="===b?c&&0===e.indexOf(c):"*="===b?c&&e.indexOf(c)>-1:"$="===b?c&&e.slice(-c.length)===c:"~="===b?(" "+e+" ").indexOf(c)>-1:"|="===b?e===c||e.slice(0,c.length+1)===c+"-":!1):!0}},CHILD:function(a,b,c,d,e){var f="nth"!==a.slice(0,3),g="last"!==a.slice(-4),h="of-type"===b;return 1===d&&0===e?function(a){return!!a.parentNode}:function(b,c,i){var j,k,l,m,n,o,p=f!==g?"nextSibling":"previousSibling",q=b.parentNode,r=h&&b.nodeName.toLowerCase(),s=!i&&!h;if(q){if(f){while(p){l=b;while(l=l[p])if(h?l.nodeName.toLowerCase()===r:1===l.nodeType)return!1;o=p="only"===a&&!o&&"nextSibling"}return!0}if(o=[g?q.firstChild:q.lastChild],g&&s){k=q[u]||(q[u]={}),j=k[a]||[],n=j[0]===w&&j[1],m=j[0]===w&&j[2],l=n&&q.childNodes[n];while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if(1===l.nodeType&&++m&&l===b){k[a]=[w,n,m];break}}else if(s&&(j=(b[u]||(b[u]={}))[a])&&j[0]===w)m=j[1];else while(l=++n&&l&&l[p]||(m=n=0)||o.pop())if((h?l.nodeName.toLowerCase()===r:1===l.nodeType)&&++m&&(s&&((l[u]||(l[u]={}))[a]=[w,m]),l===b))break;return m-=e,m===d||m%d===0&&m/d>=0}}},PSEUDO:function(a,b){var c,e=d.pseudos[a]||d.setFilters[a.toLowerCase()]||fb.error("unsupported pseudo: "+a);return e[u]?e(b):e.length>1?(c=[a,a,"",b],d.setFilters.hasOwnProperty(a.toLowerCase())?hb(function(a,c){var d,f=e(a,b),g=f.length;while(g--)d=K.call(a,f[g]),a[d]=!(c[d]=f[g])}):function(a){return e(a,0,c)}):e}},pseudos:{not:hb(function(a){var b=[],c=[],d=h(a.replace(R,"$1"));return d[u]?hb(function(a,b,c,e){var f,g=d(a,null,e,[]),h=a.length;while(h--)(f=g[h])&&(a[h]=!(b[h]=f))}):function(a,e,f){return b[0]=a,d(b,null,f,c),!c.pop()}}),has:hb(function(a){return function(b){return fb(a,b).length>0}}),contains:hb(function(a){return function(b){return(b.textContent||b.innerText||e(b)).indexOf(a)>-1}}),lang:hb(function(a){return W.test(a||"")||fb.error("unsupported lang: "+a),a=a.replace(cb,db).toLowerCase(),function(b){var c;do if(c=p?b.lang:b.getAttribute("xml:lang")||b.getAttribute("lang"))return c=c.toLowerCase(),c===a||0===c.indexOf(a+"-");while((b=b.parentNode)&&1===b.nodeType);return!1}}),target:function(b){var c=a.location&&a.location.hash;return c&&c.slice(1)===b.id},root:function(a){return a===o},focus:function(a){return a===n.activeElement&&(!n.hasFocus||n.hasFocus())&&!!(a.type||a.href||~a.tabIndex)},enabled:function(a){return a.disabled===!1},disabled:function(a){return a.disabled===!0},checked:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&!!a.checked||"option"===b&&!!a.selected},selected:function(a){return a.parentNode&&a.parentNode.selectedIndex,a.selected===!0},empty:function(a){for(a=a.firstChild;a;a=a.nextSibling)if(a.nodeType<6)return!1;return!0},parent:function(a){return!d.pseudos.empty(a)},header:function(a){return Z.test(a.nodeName)},input:function(a){return Y.test(a.nodeName)},button:function(a){var b=a.nodeName.toLowerCase();return"input"===b&&"button"===a.type||"button"===b},text:function(a){var b;return"input"===a.nodeName.toLowerCase()&&"text"===a.type&&(null==(b=a.getAttribute("type"))||"text"===b.toLowerCase())},first:nb(function(){return[0]}),last:nb(function(a,b){return[b-1]}),eq:nb(function(a,b,c){return[0>c?c+b:c]}),even:nb(function(a,b){for(var c=0;b>c;c+=2)a.push(c);return a}),odd:nb(function(a,b){for(var c=1;b>c;c+=2)a.push(c);return a}),lt:nb(function(a,b,c){for(var d=0>c?c+b:c;--d>=0;)a.push(d);return a}),gt:nb(function(a,b,c){for(var d=0>c?c+b:c;++d<b;)a.push(d);return a})}},d.pseudos.nth=d.pseudos.eq;for(b in{radio:!0,checkbox:!0,file:!0,password:!0,image:!0})d.pseudos[b]=lb(b);for(b in{submit:!0,reset:!0})d.pseudos[b]=mb(b);function pb(){}pb.prototype=d.filters=d.pseudos,d.setFilters=new pb,g=fb.tokenize=function(a,b){var c,e,f,g,h,i,j,k=z[a+" "];if(k)return b?0:k.slice(0);h=a,i=[],j=d.preFilter;while(h){(!c||(e=S.exec(h)))&&(e&&(h=h.slice(e[0].length)||h),i.push(f=[])),c=!1,(e=T.exec(h))&&(c=e.shift(),f.push({value:c,type:e[0].replace(R," ")}),h=h.slice(c.length));for(g in d.filter)!(e=X[g].exec(h))||j[g]&&!(e=j[g](e))||(c=e.shift(),f.push({value:c,type:g,matches:e}),h=h.slice(c.length));if(!c)break}return b?h.length:h?fb.error(a):z(a,i).slice(0)};function qb(a){for(var b=0,c=a.length,d="";c>b;b++)d+=a[b].value;return d}function rb(a,b,c){var d=b.dir,e=c&&"parentNode"===d,f=x++;return b.first?function(b,c,f){while(b=b[d])if(1===b.nodeType||e)return a(b,c,f)}:function(b,c,g){var h,i,j=[w,f];if(g){while(b=b[d])if((1===b.nodeType||e)&&a(b,c,g))return!0}else while(b=b[d])if(1===b.nodeType||e){if(i=b[u]||(b[u]={}),(h=i[d])&&h[0]===w&&h[1]===f)return j[2]=h[2];if(i[d]=j,j[2]=a(b,c,g))return!0}}}function sb(a){return a.length>1?function(b,c,d){var e=a.length;while(e--)if(!a[e](b,c,d))return!1;return!0}:a[0]}function tb(a,b,c){for(var d=0,e=b.length;e>d;d++)fb(a,b[d],c);return c}function ub(a,b,c,d,e){for(var f,g=[],h=0,i=a.length,j=null!=b;i>h;h++)(f=a[h])&&(!c||c(f,d,e))&&(g.push(f),j&&b.push(h));return g}function vb(a,b,c,d,e,f){return d&&!d[u]&&(d=vb(d)),e&&!e[u]&&(e=vb(e,f)),hb(function(f,g,h,i){var j,k,l,m=[],n=[],o=g.length,p=f||tb(b||"*",h.nodeType?[h]:h,[]),q=!a||!f&&b?p:ub(p,m,a,h,i),r=c?e||(f?a:o||d)?[]:g:q;if(c&&c(q,r,h,i),d){j=ub(r,n),d(j,[],h,i),k=j.length;while(k--)(l=j[k])&&(r[n[k]]=!(q[n[k]]=l))}if(f){if(e||a){if(e){j=[],k=r.length;while(k--)(l=r[k])&&j.push(q[k]=l);e(null,r=[],j,i)}k=r.length;while(k--)(l=r[k])&&(j=e?K.call(f,l):m[k])>-1&&(f[j]=!(g[j]=l))}}else r=ub(r===g?r.splice(o,r.length):r),e?e(null,g,r,i):I.apply(g,r)})}function wb(a){for(var b,c,e,f=a.length,g=d.relative[a[0].type],h=g||d.relative[" "],i=g?1:0,k=rb(function(a){return a===b},h,!0),l=rb(function(a){return K.call(b,a)>-1},h,!0),m=[function(a,c,d){return!g&&(d||c!==j)||((b=c).nodeType?k(a,c,d):l(a,c,d))}];f>i;i++)if(c=d.relative[a[i].type])m=[rb(sb(m),c)];else{if(c=d.filter[a[i].type].apply(null,a[i].matches),c[u]){for(e=++i;f>e;e++)if(d.relative[a[e].type])break;return vb(i>1&&sb(m),i>1&&qb(a.slice(0,i-1).concat({value:" "===a[i-2].type?"*":""})).replace(R,"$1"),c,e>i&&wb(a.slice(i,e)),f>e&&wb(a=a.slice(e)),f>e&&qb(a))}m.push(c)}return sb(m)}function xb(a,b){var c=b.length>0,e=a.length>0,f=function(f,g,h,i,k){var l,m,o,p=0,q="0",r=f&&[],s=[],t=j,u=f||e&&d.find.TAG("*",k),v=w+=null==t?1:Math.random()||.1,x=u.length;for(k&&(j=g!==n&&g);q!==x&&null!=(l=u[q]);q++){if(e&&l){m=0;while(o=a[m++])if(o(l,g,h)){i.push(l);break}k&&(w=v)}c&&((l=!o&&l)&&p--,f&&r.push(l))}if(p+=q,c&&q!==p){m=0;while(o=b[m++])o(r,s,g,h);if(f){if(p>0)while(q--)r[q]||s[q]||(s[q]=G.call(i));s=ub(s)}I.apply(i,s),k&&!f&&s.length>0&&p+b.length>1&&fb.uniqueSort(i)}return k&&(w=v,j=t),r};return c?hb(f):f}return h=fb.compile=function(a,b){var c,d=[],e=[],f=A[a+" "];if(!f){b||(b=g(a)),c=b.length;while(c--)f=wb(b[c]),f[u]?d.push(f):e.push(f);f=A(a,xb(e,d)),f.selector=a}return f},i=fb.select=function(a,b,e,f){var i,j,k,l,m,n="function"==typeof a&&a,o=!f&&g(a=n.selector||a);if(e=e||[],1===o.length){if(j=o[0]=o[0].slice(0),j.length>2&&"ID"===(k=j[0]).type&&c.getById&&9===b.nodeType&&p&&d.relative[j[1].type]){if(b=(d.find.ID(k.matches[0].replace(cb,db),b)||[])[0],!b)return e;n&&(b=b.parentNode),a=a.slice(j.shift().value.length)}i=X.needsContext.test(a)?0:j.length;while(i--){if(k=j[i],d.relative[l=k.type])break;if((m=d.find[l])&&(f=m(k.matches[0].replace(cb,db),ab.test(j[0].type)&&ob(b.parentNode)||b))){if(j.splice(i,1),a=f.length&&qb(j),!a)return I.apply(e,f),e;break}}}return(n||h(a,o))(f,b,!p,e,ab.test(a)&&ob(b.parentNode)||b),e},c.sortStable=u.split("").sort(B).join("")===u,c.detectDuplicates=!!l,m(),c.sortDetached=ib(function(a){return 1&a.compareDocumentPosition(n.createElement("div"))}),ib(function(a){return a.innerHTML="<a href='#'></a>","#"===a.firstChild.getAttribute("href")})||jb("type|href|height|width",function(a,b,c){return c?void 0:a.getAttribute(b,"type"===b.toLowerCase()?1:2)}),c.attributes&&ib(function(a){return a.innerHTML="<input/>",a.firstChild.setAttribute("value",""),""===a.firstChild.getAttribute("value")})||jb("value",function(a,b,c){return c||"input"!==a.nodeName.toLowerCase()?void 0:a.defaultValue}),ib(function(a){return null==a.getAttribute("disabled")})||jb(L,function(a,b,c){var d;return c?void 0:a[b]===!0?b.toLowerCase():(d=a.getAttributeNode(b))&&d.specified?d.value:null}),fb}(a);n.find=t,n.expr=t.selectors,n.expr[":"]=n.expr.pseudos,n.unique=t.uniqueSort,n.text=t.getText,n.isXMLDoc=t.isXML,n.contains=t.contains;var u=n.expr.match.needsContext,v=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,w=/^.[^:#\[\.,]*$/;function x(a,b,c){if(n.isFunction(b))return n.grep(a,function(a,d){return!!b.call(a,d,a)!==c});if(b.nodeType)return n.grep(a,function(a){return a===b!==c});if("string"==typeof b){if(w.test(b))return n.filter(b,a,c);b=n.filter(b,a)}return n.grep(a,function(a){return g.call(b,a)>=0!==c})}n.filter=function(a,b,c){var d=b[0];return c&&(a=":not("+a+")"),1===b.length&&1===d.nodeType?n.find.matchesSelector(d,a)?[d]:[]:n.find.matches(a,n.grep(b,function(a){return 1===a.nodeType}))},n.fn.extend({find:function(a){var b,c=this.length,d=[],e=this;if("string"!=typeof a)return this.pushStack(n(a).filter(function(){for(b=0;c>b;b++)if(n.contains(e[b],this))return!0}));for(b=0;c>b;b++)n.find(a,e[b],d);return d=this.pushStack(c>1?n.unique(d):d),d.selector=this.selector?this.selector+" "+a:a,d},filter:function(a){return this.pushStack(x(this,a||[],!1))},not:function(a){return this.pushStack(x(this,a||[],!0))},is:function(a){return!!x(this,"string"==typeof a&&u.test(a)?n(a):a||[],!1).length}});var y,z=/^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,A=n.fn.init=function(a,b){var c,d;if(!a)return this;if("string"==typeof a){if(c="<"===a[0]&&">"===a[a.length-1]&&a.length>=3?[null,a,null]:z.exec(a),!c||!c[1]&&b)return!b||b.jquery?(b||y).find(a):this.constructor(b).find(a);if(c[1]){if(b=b instanceof n?b[0]:b,n.merge(this,n.parseHTML(c[1],b&&b.nodeType?b.ownerDocument||b:l,!0)),v.test(c[1])&&n.isPlainObject(b))for(c in b)n.isFunction(this[c])?this[c](b[c]):this.attr(c,b[c]);return this}return d=l.getElementById(c[2]),d&&d.parentNode&&(this.length=1,this[0]=d),this.context=l,this.selector=a,this}return a.nodeType?(this.context=this[0]=a,this.length=1,this):n.isFunction(a)?"undefined"!=typeof y.ready?y.ready(a):a(n):(void 0!==a.selector&&(this.selector=a.selector,this.context=a.context),n.makeArray(a,this))};A.prototype=n.fn,y=n(l);var B=/^(?:parents|prev(?:Until|All))/,C={children:!0,contents:!0,next:!0,prev:!0};n.extend({dir:function(a,b,c){var d=[],e=void 0!==c;while((a=a[b])&&9!==a.nodeType)if(1===a.nodeType){if(e&&n(a).is(c))break;d.push(a)}return d},sibling:function(a,b){for(var c=[];a;a=a.nextSibling)1===a.nodeType&&a!==b&&c.push(a);return c}}),n.fn.extend({has:function(a){var b=n(a,this),c=b.length;return this.filter(function(){for(var a=0;c>a;a++)if(n.contains(this,b[a]))return!0})},closest:function(a,b){for(var c,d=0,e=this.length,f=[],g=u.test(a)||"string"!=typeof a?n(a,b||this.context):0;e>d;d++)for(c=this[d];c&&c!==b;c=c.parentNode)if(c.nodeType<11&&(g?g.index(c)>-1:1===c.nodeType&&n.find.matchesSelector(c,a))){f.push(c);break}return this.pushStack(f.length>1?n.unique(f):f)},index:function(a){return a?"string"==typeof a?g.call(n(a),this[0]):g.call(this,a.jquery?a[0]:a):this[0]&&this[0].parentNode?this.first().prevAll().length:-1},add:function(a,b){return this.pushStack(n.unique(n.merge(this.get(),n(a,b))))},addBack:function(a){return this.add(null==a?this.prevObject:this.prevObject.filter(a))}});function D(a,b){while((a=a[b])&&1!==a.nodeType);return a}n.each({parent:function(a){var b=a.parentNode;return b&&11!==b.nodeType?b:null},parents:function(a){return n.dir(a,"parentNode")},parentsUntil:function(a,b,c){return n.dir(a,"parentNode",c)},next:function(a){return D(a,"nextSibling")},prev:function(a){return D(a,"previousSibling")},nextAll:function(a){return n.dir(a,"nextSibling")},prevAll:function(a){return n.dir(a,"previousSibling")},nextUntil:function(a,b,c){return n.dir(a,"nextSibling",c)},prevUntil:function(a,b,c){return n.dir(a,"previousSibling",c)},siblings:function(a){return n.sibling((a.parentNode||{}).firstChild,a)},children:function(a){return n.sibling(a.firstChild)},contents:function(a){return a.contentDocument||n.merge([],a.childNodes)}},function(a,b){n.fn[a]=function(c,d){var e=n.map(this,b,c);return"Until"!==a.slice(-5)&&(d=c),d&&"string"==typeof d&&(e=n.filter(d,e)),this.length>1&&(C[a]||n.unique(e),B.test(a)&&e.reverse()),this.pushStack(e)}});var E=/\S+/g,F={};function G(a){var b=F[a]={};return n.each(a.match(E)||[],function(a,c){b[c]=!0}),b}n.Callbacks=function(a){a="string"==typeof a?F[a]||G(a):n.extend({},a);var b,c,d,e,f,g,h=[],i=!a.once&&[],j=function(l){for(b=a.memory&&l,c=!0,g=e||0,e=0,f=h.length,d=!0;h&&f>g;g++)if(h[g].apply(l[0],l[1])===!1&&a.stopOnFalse){b=!1;break}d=!1,h&&(i?i.length&&j(i.shift()):b?h=[]:k.disable())},k={add:function(){if(h){var c=h.length;!function g(b){n.each(b,function(b,c){var d=n.type(c);"function"===d?a.unique&&k.has(c)||h.push(c):c&&c.length&&"string"!==d&&g(c)})}(arguments),d?f=h.length:b&&(e=c,j(b))}return this},remove:function(){return h&&n.each(arguments,function(a,b){var c;while((c=n.inArray(b,h,c))>-1)h.splice(c,1),d&&(f>=c&&f--,g>=c&&g--)}),this},has:function(a){return a?n.inArray(a,h)>-1:!(!h||!h.length)},empty:function(){return h=[],f=0,this},disable:function(){return h=i=b=void 0,this},disabled:function(){return!h},lock:function(){return i=void 0,b||k.disable(),this},locked:function(){return!i},fireWith:function(a,b){return!h||c&&!i||(b=b||[],b=[a,b.slice?b.slice():b],d?i.push(b):j(b)),this},fire:function(){return k.fireWith(this,arguments),this},fired:function(){return!!c}};return k},n.extend({Deferred:function(a){var b=[["resolve","done",n.Callbacks("once memory"),"resolved"],["reject","fail",n.Callbacks("once memory"),"rejected"],["notify","progress",n.Callbacks("memory")]],c="pending",d={state:function(){return c},always:function(){return e.done(arguments).fail(arguments),this},then:function(){var a=arguments;return n.Deferred(function(c){n.each(b,function(b,f){var g=n.isFunction(a[b])&&a[b];e[f[1]](function(){var a=g&&g.apply(this,arguments);a&&n.isFunction(a.promise)?a.promise().done(c.resolve).fail(c.reject).progress(c.notify):c[f[0]+"With"](this===d?c.promise():this,g?[a]:arguments)})}),a=null}).promise()},promise:function(a){return null!=a?n.extend(a,d):d}},e={};return d.pipe=d.then,n.each(b,function(a,f){var g=f[2],h=f[3];d[f[1]]=g.add,h&&g.add(function(){c=h},b[1^a][2].disable,b[2][2].lock),e[f[0]]=function(){return e[f[0]+"With"](this===e?d:this,arguments),this},e[f[0]+"With"]=g.fireWith}),d.promise(e),a&&a.call(e,e),e},when:function(a){var b=0,c=d.call(arguments),e=c.length,f=1!==e||a&&n.isFunction(a.promise)?e:0,g=1===f?a:n.Deferred(),h=function(a,b,c){return function(e){b[a]=this,c[a]=arguments.length>1?d.call(arguments):e,c===i?g.notifyWith(b,c):--f||g.resolveWith(b,c)}},i,j,k;if(e>1)for(i=new Array(e),j=new Array(e),k=new Array(e);e>b;b++)c[b]&&n.isFunction(c[b].promise)?c[b].promise().done(h(b,k,c)).fail(g.reject).progress(h(b,j,i)):--f;return f||g.resolveWith(k,c),g.promise()}});var H;n.fn.ready=function(a){return n.ready.promise().done(a),this},n.extend({isReady:!1,readyWait:1,holdReady:function(a){a?n.readyWait++:n.ready(!0)},ready:function(a){(a===!0?--n.readyWait:n.isReady)||(n.isReady=!0,a!==!0&&--n.readyWait>0||(H.resolveWith(l,[n]),n.fn.triggerHandler&&(n(l).triggerHandler("ready"),n(l).off("ready"))))}});function I(){l.removeEventListener("DOMContentLoaded",I,!1),a.removeEventListener("load",I,!1),n.ready()}n.ready.promise=function(b){return H||(H=n.Deferred(),"complete"===l.readyState?setTimeout(n.ready):(l.addEventListener("DOMContentLoaded",I,!1),a.addEventListener("load",I,!1))),H.promise(b)},n.ready.promise();var J=n.access=function(a,b,c,d,e,f,g){var h=0,i=a.length,j=null==c;if("object"===n.type(c)){e=!0;for(h in c)n.access(a,b,h,c[h],!0,f,g)}else if(void 0!==d&&(e=!0,n.isFunction(d)||(g=!0),j&&(g?(b.call(a,d),b=null):(j=b,b=function(a,b,c){return j.call(n(a),c)})),b))for(;i>h;h++)b(a[h],c,g?d:d.call(a[h],h,b(a[h],c)));return e?a:j?b.call(a):i?b(a[0],c):f};n.acceptData=function(a){return 1===a.nodeType||9===a.nodeType||!+a.nodeType};function K(){Object.defineProperty(this.cache={},0,{get:function(){return{}}}),this.expando=n.expando+Math.random()}K.uid=1,K.accepts=n.acceptData,K.prototype={key:function(a){if(!K.accepts(a))return 0;var b={},c=a[this.expando];if(!c){c=K.uid++;try{b[this.expando]={value:c},Object.defineProperties(a,b)}catch(d){b[this.expando]=c,n.extend(a,b)}}return this.cache[c]||(this.cache[c]={}),c},set:function(a,b,c){var d,e=this.key(a),f=this.cache[e];if("string"==typeof b)f[b]=c;else if(n.isEmptyObject(f))n.extend(this.cache[e],b);else for(d in b)f[d]=b[d];return f},get:function(a,b){var c=this.cache[this.key(a)];return void 0===b?c:c[b]},access:function(a,b,c){var d;return void 0===b||b&&"string"==typeof b&&void 0===c?(d=this.get(a,b),void 0!==d?d:this.get(a,n.camelCase(b))):(this.set(a,b,c),void 0!==c?c:b)},remove:function(a,b){var c,d,e,f=this.key(a),g=this.cache[f];if(void 0===b)this.cache[f]={};else{n.isArray(b)?d=b.concat(b.map(n.camelCase)):(e=n.camelCase(b),b in g?d=[b,e]:(d=e,d=d in g?[d]:d.match(E)||[])),c=d.length;while(c--)delete g[d[c]]}},hasData:function(a){return!n.isEmptyObject(this.cache[a[this.expando]]||{})},discard:function(a){a[this.expando]&&delete this.cache[a[this.expando]]}};var L=new K,M=new K,N=/^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,O=/([A-Z])/g;function P(a,b,c){var d;if(void 0===c&&1===a.nodeType)if(d="data-"+b.replace(O,"-$1").toLowerCase(),c=a.getAttribute(d),"string"==typeof c){try{c="true"===c?!0:"false"===c?!1:"null"===c?null:+c+""===c?+c:N.test(c)?n.parseJSON(c):c}catch(e){}M.set(a,b,c)}else c=void 0;return c}n.extend({hasData:function(a){return M.hasData(a)||L.hasData(a)},data:function(a,b,c){return M.access(a,b,c)},removeData:function(a,b){M.remove(a,b)
},_data:function(a,b,c){return L.access(a,b,c)},_removeData:function(a,b){L.remove(a,b)}}),n.fn.extend({data:function(a,b){var c,d,e,f=this[0],g=f&&f.attributes;if(void 0===a){if(this.length&&(e=M.get(f),1===f.nodeType&&!L.get(f,"hasDataAttrs"))){c=g.length;while(c--)g[c]&&(d=g[c].name,0===d.indexOf("data-")&&(d=n.camelCase(d.slice(5)),P(f,d,e[d])));L.set(f,"hasDataAttrs",!0)}return e}return"object"==typeof a?this.each(function(){M.set(this,a)}):J(this,function(b){var c,d=n.camelCase(a);if(f&&void 0===b){if(c=M.get(f,a),void 0!==c)return c;if(c=M.get(f,d),void 0!==c)return c;if(c=P(f,d,void 0),void 0!==c)return c}else this.each(function(){var c=M.get(this,d);M.set(this,d,b),-1!==a.indexOf("-")&&void 0!==c&&M.set(this,a,b)})},null,b,arguments.length>1,null,!0)},removeData:function(a){return this.each(function(){M.remove(this,a)})}}),n.extend({queue:function(a,b,c){var d;return a?(b=(b||"fx")+"queue",d=L.get(a,b),c&&(!d||n.isArray(c)?d=L.access(a,b,n.makeArray(c)):d.push(c)),d||[]):void 0},dequeue:function(a,b){b=b||"fx";var c=n.queue(a,b),d=c.length,e=c.shift(),f=n._queueHooks(a,b),g=function(){n.dequeue(a,b)};"inprogress"===e&&(e=c.shift(),d--),e&&("fx"===b&&c.unshift("inprogress"),delete f.stop,e.call(a,g,f)),!d&&f&&f.empty.fire()},_queueHooks:function(a,b){var c=b+"queueHooks";return L.get(a,c)||L.access(a,c,{empty:n.Callbacks("once memory").add(function(){L.remove(a,[b+"queue",c])})})}}),n.fn.extend({queue:function(a,b){var c=2;return"string"!=typeof a&&(b=a,a="fx",c--),arguments.length<c?n.queue(this[0],a):void 0===b?this:this.each(function(){var c=n.queue(this,a,b);n._queueHooks(this,a),"fx"===a&&"inprogress"!==c[0]&&n.dequeue(this,a)})},dequeue:function(a){return this.each(function(){n.dequeue(this,a)})},clearQueue:function(a){return this.queue(a||"fx",[])},promise:function(a,b){var c,d=1,e=n.Deferred(),f=this,g=this.length,h=function(){--d||e.resolveWith(f,[f])};"string"!=typeof a&&(b=a,a=void 0),a=a||"fx";while(g--)c=L.get(f[g],a+"queueHooks"),c&&c.empty&&(d++,c.empty.add(h));return h(),e.promise(b)}});var Q=/[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,R=["Top","Right","Bottom","Left"],S=function(a,b){return a=b||a,"none"===n.css(a,"display")||!n.contains(a.ownerDocument,a)},T=/^(?:checkbox|radio)$/i;!function(){var a=l.createDocumentFragment(),b=a.appendChild(l.createElement("div")),c=l.createElement("input");c.setAttribute("type","radio"),c.setAttribute("checked","checked"),c.setAttribute("name","t"),b.appendChild(c),k.checkClone=b.cloneNode(!0).cloneNode(!0).lastChild.checked,b.innerHTML="<textarea>x</textarea>",k.noCloneChecked=!!b.cloneNode(!0).lastChild.defaultValue}();var U="undefined";k.focusinBubbles="onfocusin"in a;var V=/^key/,W=/^(?:mouse|pointer|contextmenu)|click/,X=/^(?:focusinfocus|focusoutblur)$/,Y=/^([^.]*)(?:\.(.+)|)$/;function Z(){return!0}function $(){return!1}function _(){try{return l.activeElement}catch(a){}}n.event={global:{},add:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.get(a);if(r){c.handler&&(f=c,c=f.handler,e=f.selector),c.guid||(c.guid=n.guid++),(i=r.events)||(i=r.events={}),(g=r.handle)||(g=r.handle=function(b){return typeof n!==U&&n.event.triggered!==b.type?n.event.dispatch.apply(a,arguments):void 0}),b=(b||"").match(E)||[""],j=b.length;while(j--)h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o&&(l=n.event.special[o]||{},o=(e?l.delegateType:l.bindType)||o,l=n.event.special[o]||{},k=n.extend({type:o,origType:q,data:d,handler:c,guid:c.guid,selector:e,needsContext:e&&n.expr.match.needsContext.test(e),namespace:p.join(".")},f),(m=i[o])||(m=i[o]=[],m.delegateCount=0,l.setup&&l.setup.call(a,d,p,g)!==!1||a.addEventListener&&a.addEventListener(o,g,!1)),l.add&&(l.add.call(a,k),k.handler.guid||(k.handler.guid=c.guid)),e?m.splice(m.delegateCount++,0,k):m.push(k),n.event.global[o]=!0)}},remove:function(a,b,c,d,e){var f,g,h,i,j,k,l,m,o,p,q,r=L.hasData(a)&&L.get(a);if(r&&(i=r.events)){b=(b||"").match(E)||[""],j=b.length;while(j--)if(h=Y.exec(b[j])||[],o=q=h[1],p=(h[2]||"").split(".").sort(),o){l=n.event.special[o]||{},o=(d?l.delegateType:l.bindType)||o,m=i[o]||[],h=h[2]&&new RegExp("(^|\\.)"+p.join("\\.(?:.*\\.|)")+"(\\.|$)"),g=f=m.length;while(f--)k=m[f],!e&&q!==k.origType||c&&c.guid!==k.guid||h&&!h.test(k.namespace)||d&&d!==k.selector&&("**"!==d||!k.selector)||(m.splice(f,1),k.selector&&m.delegateCount--,l.remove&&l.remove.call(a,k));g&&!m.length&&(l.teardown&&l.teardown.call(a,p,r.handle)!==!1||n.removeEvent(a,o,r.handle),delete i[o])}else for(o in i)n.event.remove(a,o+b[j],c,d,!0);n.isEmptyObject(i)&&(delete r.handle,L.remove(a,"events"))}},trigger:function(b,c,d,e){var f,g,h,i,k,m,o,p=[d||l],q=j.call(b,"type")?b.type:b,r=j.call(b,"namespace")?b.namespace.split("."):[];if(g=h=d=d||l,3!==d.nodeType&&8!==d.nodeType&&!X.test(q+n.event.triggered)&&(q.indexOf(".")>=0&&(r=q.split("."),q=r.shift(),r.sort()),k=q.indexOf(":")<0&&"on"+q,b=b[n.expando]?b:new n.Event(q,"object"==typeof b&&b),b.isTrigger=e?2:3,b.namespace=r.join("."),b.namespace_re=b.namespace?new RegExp("(^|\\.)"+r.join("\\.(?:.*\\.|)")+"(\\.|$)"):null,b.result=void 0,b.target||(b.target=d),c=null==c?[b]:n.makeArray(c,[b]),o=n.event.special[q]||{},e||!o.trigger||o.trigger.apply(d,c)!==!1)){if(!e&&!o.noBubble&&!n.isWindow(d)){for(i=o.delegateType||q,X.test(i+q)||(g=g.parentNode);g;g=g.parentNode)p.push(g),h=g;h===(d.ownerDocument||l)&&p.push(h.defaultView||h.parentWindow||a)}f=0;while((g=p[f++])&&!b.isPropagationStopped())b.type=f>1?i:o.bindType||q,m=(L.get(g,"events")||{})[b.type]&&L.get(g,"handle"),m&&m.apply(g,c),m=k&&g[k],m&&m.apply&&n.acceptData(g)&&(b.result=m.apply(g,c),b.result===!1&&b.preventDefault());return b.type=q,e||b.isDefaultPrevented()||o._default&&o._default.apply(p.pop(),c)!==!1||!n.acceptData(d)||k&&n.isFunction(d[q])&&!n.isWindow(d)&&(h=d[k],h&&(d[k]=null),n.event.triggered=q,d[q](),n.event.triggered=void 0,h&&(d[k]=h)),b.result}},dispatch:function(a){a=n.event.fix(a);var b,c,e,f,g,h=[],i=d.call(arguments),j=(L.get(this,"events")||{})[a.type]||[],k=n.event.special[a.type]||{};if(i[0]=a,a.delegateTarget=this,!k.preDispatch||k.preDispatch.call(this,a)!==!1){h=n.event.handlers.call(this,a,j),b=0;while((f=h[b++])&&!a.isPropagationStopped()){a.currentTarget=f.elem,c=0;while((g=f.handlers[c++])&&!a.isImmediatePropagationStopped())(!a.namespace_re||a.namespace_re.test(g.namespace))&&(a.handleObj=g,a.data=g.data,e=((n.event.special[g.origType]||{}).handle||g.handler).apply(f.elem,i),void 0!==e&&(a.result=e)===!1&&(a.preventDefault(),a.stopPropagation()))}return k.postDispatch&&k.postDispatch.call(this,a),a.result}},handlers:function(a,b){var c,d,e,f,g=[],h=b.delegateCount,i=a.target;if(h&&i.nodeType&&(!a.button||"click"!==a.type))for(;i!==this;i=i.parentNode||this)if(i.disabled!==!0||"click"!==a.type){for(d=[],c=0;h>c;c++)f=b[c],e=f.selector+" ",void 0===d[e]&&(d[e]=f.needsContext?n(e,this).index(i)>=0:n.find(e,this,null,[i]).length),d[e]&&d.push(f);d.length&&g.push({elem:i,handlers:d})}return h<b.length&&g.push({elem:this,handlers:b.slice(h)}),g},props:"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(a,b){return null==a.which&&(a.which=null!=b.charCode?b.charCode:b.keyCode),a}},mouseHooks:{props:"button buttons clientX clientY offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(a,b){var c,d,e,f=b.button;return null==a.pageX&&null!=b.clientX&&(c=a.target.ownerDocument||l,d=c.documentElement,e=c.body,a.pageX=b.clientX+(d&&d.scrollLeft||e&&e.scrollLeft||0)-(d&&d.clientLeft||e&&e.clientLeft||0),a.pageY=b.clientY+(d&&d.scrollTop||e&&e.scrollTop||0)-(d&&d.clientTop||e&&e.clientTop||0)),a.which||void 0===f||(a.which=1&f?1:2&f?3:4&f?2:0),a}},fix:function(a){if(a[n.expando])return a;var b,c,d,e=a.type,f=a,g=this.fixHooks[e];g||(this.fixHooks[e]=g=W.test(e)?this.mouseHooks:V.test(e)?this.keyHooks:{}),d=g.props?this.props.concat(g.props):this.props,a=new n.Event(f),b=d.length;while(b--)c=d[b],a[c]=f[c];return a.target||(a.target=l),3===a.target.nodeType&&(a.target=a.target.parentNode),g.filter?g.filter(a,f):a},special:{load:{noBubble:!0},focus:{trigger:function(){return this!==_()&&this.focus?(this.focus(),!1):void 0},delegateType:"focusin"},blur:{trigger:function(){return this===_()&&this.blur?(this.blur(),!1):void 0},delegateType:"focusout"},click:{trigger:function(){return"checkbox"===this.type&&this.click&&n.nodeName(this,"input")?(this.click(),!1):void 0},_default:function(a){return n.nodeName(a.target,"a")}},beforeunload:{postDispatch:function(a){void 0!==a.result&&a.originalEvent&&(a.originalEvent.returnValue=a.result)}}},simulate:function(a,b,c,d){var e=n.extend(new n.Event,c,{type:a,isSimulated:!0,originalEvent:{}});d?n.event.trigger(e,null,b):n.event.dispatch.call(b,e),e.isDefaultPrevented()&&c.preventDefault()}},n.removeEvent=function(a,b,c){a.removeEventListener&&a.removeEventListener(b,c,!1)},n.Event=function(a,b){return this instanceof n.Event?(a&&a.type?(this.originalEvent=a,this.type=a.type,this.isDefaultPrevented=a.defaultPrevented||void 0===a.defaultPrevented&&a.returnValue===!1?Z:$):this.type=a,b&&n.extend(this,b),this.timeStamp=a&&a.timeStamp||n.now(),void(this[n.expando]=!0)):new n.Event(a,b)},n.Event.prototype={isDefaultPrevented:$,isPropagationStopped:$,isImmediatePropagationStopped:$,preventDefault:function(){var a=this.originalEvent;this.isDefaultPrevented=Z,a&&a.preventDefault&&a.preventDefault()},stopPropagation:function(){var a=this.originalEvent;this.isPropagationStopped=Z,a&&a.stopPropagation&&a.stopPropagation()},stopImmediatePropagation:function(){var a=this.originalEvent;this.isImmediatePropagationStopped=Z,a&&a.stopImmediatePropagation&&a.stopImmediatePropagation(),this.stopPropagation()}},n.each({mouseenter:"mouseover",mouseleave:"mouseout",pointerenter:"pointerover",pointerleave:"pointerout"},function(a,b){n.event.special[a]={delegateType:b,bindType:b,handle:function(a){var c,d=this,e=a.relatedTarget,f=a.handleObj;return(!e||e!==d&&!n.contains(d,e))&&(a.type=f.origType,c=f.handler.apply(this,arguments),a.type=b),c}}}),k.focusinBubbles||n.each({focus:"focusin",blur:"focusout"},function(a,b){var c=function(a){n.event.simulate(b,a.target,n.event.fix(a),!0)};n.event.special[b]={setup:function(){var d=this.ownerDocument||this,e=L.access(d,b);e||d.addEventListener(a,c,!0),L.access(d,b,(e||0)+1)},teardown:function(){var d=this.ownerDocument||this,e=L.access(d,b)-1;e?L.access(d,b,e):(d.removeEventListener(a,c,!0),L.remove(d,b))}}}),n.fn.extend({on:function(a,b,c,d,e){var f,g;if("object"==typeof a){"string"!=typeof b&&(c=c||b,b=void 0);for(g in a)this.on(g,b,c,a[g],e);return this}if(null==c&&null==d?(d=b,c=b=void 0):null==d&&("string"==typeof b?(d=c,c=void 0):(d=c,c=b,b=void 0)),d===!1)d=$;else if(!d)return this;return 1===e&&(f=d,d=function(a){return n().off(a),f.apply(this,arguments)},d.guid=f.guid||(f.guid=n.guid++)),this.each(function(){n.event.add(this,a,d,c,b)})},one:function(a,b,c,d){return this.on(a,b,c,d,1)},off:function(a,b,c){var d,e;if(a&&a.preventDefault&&a.handleObj)return d=a.handleObj,n(a.delegateTarget).off(d.namespace?d.origType+"."+d.namespace:d.origType,d.selector,d.handler),this;if("object"==typeof a){for(e in a)this.off(e,b,a[e]);return this}return(b===!1||"function"==typeof b)&&(c=b,b=void 0),c===!1&&(c=$),this.each(function(){n.event.remove(this,a,c,b)})},trigger:function(a,b){return this.each(function(){n.event.trigger(a,b,this)})},triggerHandler:function(a,b){var c=this[0];return c?n.event.trigger(a,b,c,!0):void 0}});var ab=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,bb=/<([\w:]+)/,cb=/<|&#?\w+;/,db=/<(?:script|style|link)/i,eb=/checked\s*(?:[^=]|=\s*.checked.)/i,fb=/^$|\/(?:java|ecma)script/i,gb=/^true\/(.*)/,hb=/^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g,ib={option:[1,"<select multiple='multiple'>","</select>"],thead:[1,"<table>","</table>"],col:[2,"<table><colgroup>","</colgroup></table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],_default:[0,"",""]};ib.optgroup=ib.option,ib.tbody=ib.tfoot=ib.colgroup=ib.caption=ib.thead,ib.th=ib.td;function jb(a,b){return n.nodeName(a,"table")&&n.nodeName(11!==b.nodeType?b:b.firstChild,"tr")?a.getElementsByTagName("tbody")[0]||a.appendChild(a.ownerDocument.createElement("tbody")):a}function kb(a){return a.type=(null!==a.getAttribute("type"))+"/"+a.type,a}function lb(a){var b=gb.exec(a.type);return b?a.type=b[1]:a.removeAttribute("type"),a}function mb(a,b){for(var c=0,d=a.length;d>c;c++)L.set(a[c],"globalEval",!b||L.get(b[c],"globalEval"))}function nb(a,b){var c,d,e,f,g,h,i,j;if(1===b.nodeType){if(L.hasData(a)&&(f=L.access(a),g=L.set(b,f),j=f.events)){delete g.handle,g.events={};for(e in j)for(c=0,d=j[e].length;d>c;c++)n.event.add(b,e,j[e][c])}M.hasData(a)&&(h=M.access(a),i=n.extend({},h),M.set(b,i))}}function ob(a,b){var c=a.getElementsByTagName?a.getElementsByTagName(b||"*"):a.querySelectorAll?a.querySelectorAll(b||"*"):[];return void 0===b||b&&n.nodeName(a,b)?n.merge([a],c):c}function pb(a,b){var c=b.nodeName.toLowerCase();"input"===c&&T.test(a.type)?b.checked=a.checked:("input"===c||"textarea"===c)&&(b.defaultValue=a.defaultValue)}n.extend({clone:function(a,b,c){var d,e,f,g,h=a.cloneNode(!0),i=n.contains(a.ownerDocument,a);if(!(k.noCloneChecked||1!==a.nodeType&&11!==a.nodeType||n.isXMLDoc(a)))for(g=ob(h),f=ob(a),d=0,e=f.length;e>d;d++)pb(f[d],g[d]);if(b)if(c)for(f=f||ob(a),g=g||ob(h),d=0,e=f.length;e>d;d++)nb(f[d],g[d]);else nb(a,h);return g=ob(h,"script"),g.length>0&&mb(g,!i&&ob(a,"script")),h},buildFragment:function(a,b,c,d){for(var e,f,g,h,i,j,k=b.createDocumentFragment(),l=[],m=0,o=a.length;o>m;m++)if(e=a[m],e||0===e)if("object"===n.type(e))n.merge(l,e.nodeType?[e]:e);else if(cb.test(e)){f=f||k.appendChild(b.createElement("div")),g=(bb.exec(e)||["",""])[1].toLowerCase(),h=ib[g]||ib._default,f.innerHTML=h[1]+e.replace(ab,"<$1></$2>")+h[2],j=h[0];while(j--)f=f.lastChild;n.merge(l,f.childNodes),f=k.firstChild,f.textContent=""}else l.push(b.createTextNode(e));k.textContent="",m=0;while(e=l[m++])if((!d||-1===n.inArray(e,d))&&(i=n.contains(e.ownerDocument,e),f=ob(k.appendChild(e),"script"),i&&mb(f),c)){j=0;while(e=f[j++])fb.test(e.type||"")&&c.push(e)}return k},cleanData:function(a){for(var b,c,d,e,f=n.event.special,g=0;void 0!==(c=a[g]);g++){if(n.acceptData(c)&&(e=c[L.expando],e&&(b=L.cache[e]))){if(b.events)for(d in b.events)f[d]?n.event.remove(c,d):n.removeEvent(c,d,b.handle);L.cache[e]&&delete L.cache[e]}delete M.cache[c[M.expando]]}}}),n.fn.extend({text:function(a){return J(this,function(a){return void 0===a?n.text(this):this.empty().each(function(){(1===this.nodeType||11===this.nodeType||9===this.nodeType)&&(this.textContent=a)})},null,a,arguments.length)},append:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=jb(this,a);b.appendChild(a)}})},prepend:function(){return this.domManip(arguments,function(a){if(1===this.nodeType||11===this.nodeType||9===this.nodeType){var b=jb(this,a);b.insertBefore(a,b.firstChild)}})},before:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this)})},after:function(){return this.domManip(arguments,function(a){this.parentNode&&this.parentNode.insertBefore(a,this.nextSibling)})},remove:function(a,b){for(var c,d=a?n.filter(a,this):this,e=0;null!=(c=d[e]);e++)b||1!==c.nodeType||n.cleanData(ob(c)),c.parentNode&&(b&&n.contains(c.ownerDocument,c)&&mb(ob(c,"script")),c.parentNode.removeChild(c));return this},empty:function(){for(var a,b=0;null!=(a=this[b]);b++)1===a.nodeType&&(n.cleanData(ob(a,!1)),a.textContent="");return this},clone:function(a,b){return a=null==a?!1:a,b=null==b?a:b,this.map(function(){return n.clone(this,a,b)})},html:function(a){return J(this,function(a){var b=this[0]||{},c=0,d=this.length;if(void 0===a&&1===b.nodeType)return b.innerHTML;if("string"==typeof a&&!db.test(a)&&!ib[(bb.exec(a)||["",""])[1].toLowerCase()]){a=a.replace(ab,"<$1></$2>");try{for(;d>c;c++)b=this[c]||{},1===b.nodeType&&(n.cleanData(ob(b,!1)),b.innerHTML=a);b=0}catch(e){}}b&&this.empty().append(a)},null,a,arguments.length)},replaceWith:function(){var a=arguments[0];return this.domManip(arguments,function(b){a=this.parentNode,n.cleanData(ob(this)),a&&a.replaceChild(b,this)}),a&&(a.length||a.nodeType)?this:this.remove()},detach:function(a){return this.remove(a,!0)},domManip:function(a,b){a=e.apply([],a);var c,d,f,g,h,i,j=0,l=this.length,m=this,o=l-1,p=a[0],q=n.isFunction(p);if(q||l>1&&"string"==typeof p&&!k.checkClone&&eb.test(p))return this.each(function(c){var d=m.eq(c);q&&(a[0]=p.call(this,c,d.html())),d.domManip(a,b)});if(l&&(c=n.buildFragment(a,this[0].ownerDocument,!1,this),d=c.firstChild,1===c.childNodes.length&&(c=d),d)){for(f=n.map(ob(c,"script"),kb),g=f.length;l>j;j++)h=c,j!==o&&(h=n.clone(h,!0,!0),g&&n.merge(f,ob(h,"script"))),b.call(this[j],h,j);if(g)for(i=f[f.length-1].ownerDocument,n.map(f,lb),j=0;g>j;j++)h=f[j],fb.test(h.type||"")&&!L.access(h,"globalEval")&&n.contains(i,h)&&(h.src?n._evalUrl&&n._evalUrl(h.src):n.globalEval(h.textContent.replace(hb,"")))}return this}}),n.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(a,b){n.fn[a]=function(a){for(var c,d=[],e=n(a),g=e.length-1,h=0;g>=h;h++)c=h===g?this:this.clone(!0),n(e[h])[b](c),f.apply(d,c.get());return this.pushStack(d)}});var qb,rb={};function sb(b,c){var d,e=n(c.createElement(b)).appendTo(c.body),f=a.getDefaultComputedStyle&&(d=a.getDefaultComputedStyle(e[0]))?d.display:n.css(e[0],"display");return e.detach(),f}function tb(a){var b=l,c=rb[a];return c||(c=sb(a,b),"none"!==c&&c||(qb=(qb||n("<iframe frameborder='0' width='0' height='0'/>")).appendTo(b.documentElement),b=qb[0].contentDocument,b.write(),b.close(),c=sb(a,b),qb.detach()),rb[a]=c),c}var ub=/^margin/,vb=new RegExp("^("+Q+")(?!px)[a-z%]+$","i"),wb=function(a){return a.ownerDocument.defaultView.getComputedStyle(a,null)};function xb(a,b,c){var d,e,f,g,h=a.style;return c=c||wb(a),c&&(g=c.getPropertyValue(b)||c[b]),c&&(""!==g||n.contains(a.ownerDocument,a)||(g=n.style(a,b)),vb.test(g)&&ub.test(b)&&(d=h.width,e=h.minWidth,f=h.maxWidth,h.minWidth=h.maxWidth=h.width=g,g=c.width,h.width=d,h.minWidth=e,h.maxWidth=f)),void 0!==g?g+"":g}function yb(a,b){return{get:function(){return a()?void delete this.get:(this.get=b).apply(this,arguments)}}}!function(){var b,c,d=l.documentElement,e=l.createElement("div"),f=l.createElement("div");if(f.style){f.style.backgroundClip="content-box",f.cloneNode(!0).style.backgroundClip="",k.clearCloneStyle="content-box"===f.style.backgroundClip,e.style.cssText="border:0;width:0;height:0;top:0;left:-9999px;margin-top:1px;position:absolute",e.appendChild(f);function g(){f.style.cssText="-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;display:block;margin-top:1%;top:1%;border:1px;padding:1px;width:4px;position:absolute",f.innerHTML="",d.appendChild(e);var g=a.getComputedStyle(f,null);b="1%"!==g.top,c="4px"===g.width,d.removeChild(e)}a.getComputedStyle&&n.extend(k,{pixelPosition:function(){return g(),b},boxSizingReliable:function(){return null==c&&g(),c},reliableMarginRight:function(){var b,c=f.appendChild(l.createElement("div"));return c.style.cssText=f.style.cssText="-webkit-box-sizing:content-box;-moz-box-sizing:content-box;box-sizing:content-box;display:block;margin:0;border:0;padding:0",c.style.marginRight=c.style.width="0",f.style.width="1px",d.appendChild(e),b=!parseFloat(a.getComputedStyle(c,null).marginRight),d.removeChild(e),b}})}}(),n.swap=function(a,b,c,d){var e,f,g={};for(f in b)g[f]=a.style[f],a.style[f]=b[f];e=c.apply(a,d||[]);for(f in b)a.style[f]=g[f];return e};var zb=/^(none|table(?!-c[ea]).+)/,Ab=new RegExp("^("+Q+")(.*)$","i"),Bb=new RegExp("^([+-])=("+Q+")","i"),Cb={position:"absolute",visibility:"hidden",display:"block"},Db={letterSpacing:"0",fontWeight:"400"},Eb=["Webkit","O","Moz","ms"];function Fb(a,b){if(b in a)return b;var c=b[0].toUpperCase()+b.slice(1),d=b,e=Eb.length;while(e--)if(b=Eb[e]+c,b in a)return b;return d}function Gb(a,b,c){var d=Ab.exec(b);return d?Math.max(0,d[1]-(c||0))+(d[2]||"px"):b}function Hb(a,b,c,d,e){for(var f=c===(d?"border":"content")?4:"width"===b?1:0,g=0;4>f;f+=2)"margin"===c&&(g+=n.css(a,c+R[f],!0,e)),d?("content"===c&&(g-=n.css(a,"padding"+R[f],!0,e)),"margin"!==c&&(g-=n.css(a,"border"+R[f]+"Width",!0,e))):(g+=n.css(a,"padding"+R[f],!0,e),"padding"!==c&&(g+=n.css(a,"border"+R[f]+"Width",!0,e)));return g}function Ib(a,b,c){var d=!0,e="width"===b?a.offsetWidth:a.offsetHeight,f=wb(a),g="border-box"===n.css(a,"boxSizing",!1,f);if(0>=e||null==e){if(e=xb(a,b,f),(0>e||null==e)&&(e=a.style[b]),vb.test(e))return e;d=g&&(k.boxSizingReliable()||e===a.style[b]),e=parseFloat(e)||0}return e+Hb(a,b,c||(g?"border":"content"),d,f)+"px"}function Jb(a,b){for(var c,d,e,f=[],g=0,h=a.length;h>g;g++)d=a[g],d.style&&(f[g]=L.get(d,"olddisplay"),c=d.style.display,b?(f[g]||"none"!==c||(d.style.display=""),""===d.style.display&&S(d)&&(f[g]=L.access(d,"olddisplay",tb(d.nodeName)))):(e=S(d),"none"===c&&e||L.set(d,"olddisplay",e?c:n.css(d,"display"))));for(g=0;h>g;g++)d=a[g],d.style&&(b&&"none"!==d.style.display&&""!==d.style.display||(d.style.display=b?f[g]||"":"none"));return a}n.extend({cssHooks:{opacity:{get:function(a,b){if(b){var c=xb(a,"opacity");return""===c?"1":c}}}},cssNumber:{columnCount:!0,fillOpacity:!0,flexGrow:!0,flexShrink:!0,fontWeight:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,widows:!0,zIndex:!0,zoom:!0},cssProps:{"float":"cssFloat"},style:function(a,b,c,d){if(a&&3!==a.nodeType&&8!==a.nodeType&&a.style){var e,f,g,h=n.camelCase(b),i=a.style;return b=n.cssProps[h]||(n.cssProps[h]=Fb(i,h)),g=n.cssHooks[b]||n.cssHooks[h],void 0===c?g&&"get"in g&&void 0!==(e=g.get(a,!1,d))?e:i[b]:(f=typeof c,"string"===f&&(e=Bb.exec(c))&&(c=(e[1]+1)*e[2]+parseFloat(n.css(a,b)),f="number"),null!=c&&c===c&&("number"!==f||n.cssNumber[h]||(c+="px"),k.clearCloneStyle||""!==c||0!==b.indexOf("background")||(i[b]="inherit"),g&&"set"in g&&void 0===(c=g.set(a,c,d))||(i[b]=c)),void 0)}},css:function(a,b,c,d){var e,f,g,h=n.camelCase(b);return b=n.cssProps[h]||(n.cssProps[h]=Fb(a.style,h)),g=n.cssHooks[b]||n.cssHooks[h],g&&"get"in g&&(e=g.get(a,!0,c)),void 0===e&&(e=xb(a,b,d)),"normal"===e&&b in Db&&(e=Db[b]),""===c||c?(f=parseFloat(e),c===!0||n.isNumeric(f)?f||0:e):e}}),n.each(["height","width"],function(a,b){n.cssHooks[b]={get:function(a,c,d){return c?zb.test(n.css(a,"display"))&&0===a.offsetWidth?n.swap(a,Cb,function(){return Ib(a,b,d)}):Ib(a,b,d):void 0},set:function(a,c,d){var e=d&&wb(a);return Gb(a,c,d?Hb(a,b,d,"border-box"===n.css(a,"boxSizing",!1,e),e):0)}}}),n.cssHooks.marginRight=yb(k.reliableMarginRight,function(a,b){return b?n.swap(a,{display:"inline-block"},xb,[a,"marginRight"]):void 0}),n.each({margin:"",padding:"",border:"Width"},function(a,b){n.cssHooks[a+b]={expand:function(c){for(var d=0,e={},f="string"==typeof c?c.split(" "):[c];4>d;d++)e[a+R[d]+b]=f[d]||f[d-2]||f[0];return e}},ub.test(a)||(n.cssHooks[a+b].set=Gb)}),n.fn.extend({css:function(a,b){return J(this,function(a,b,c){var d,e,f={},g=0;if(n.isArray(b)){for(d=wb(a),e=b.length;e>g;g++)f[b[g]]=n.css(a,b[g],!1,d);return f}return void 0!==c?n.style(a,b,c):n.css(a,b)},a,b,arguments.length>1)},show:function(){return Jb(this,!0)},hide:function(){return Jb(this)},toggle:function(a){return"boolean"==typeof a?a?this.show():this.hide():this.each(function(){S(this)?n(this).show():n(this).hide()})}});function Kb(a,b,c,d,e){return new Kb.prototype.init(a,b,c,d,e)}n.Tween=Kb,Kb.prototype={constructor:Kb,init:function(a,b,c,d,e,f){this.elem=a,this.prop=c,this.easing=e||"swing",this.options=b,this.start=this.now=this.cur(),this.end=d,this.unit=f||(n.cssNumber[c]?"":"px")},cur:function(){var a=Kb.propHooks[this.prop];return a&&a.get?a.get(this):Kb.propHooks._default.get(this)},run:function(a){var b,c=Kb.propHooks[this.prop];return this.pos=b=this.options.duration?n.easing[this.easing](a,this.options.duration*a,0,1,this.options.duration):a,this.now=(this.end-this.start)*b+this.start,this.options.step&&this.options.step.call(this.elem,this.now,this),c&&c.set?c.set(this):Kb.propHooks._default.set(this),this}},Kb.prototype.init.prototype=Kb.prototype,Kb.propHooks={_default:{get:function(a){var b;return null==a.elem[a.prop]||a.elem.style&&null!=a.elem.style[a.prop]?(b=n.css(a.elem,a.prop,""),b&&"auto"!==b?b:0):a.elem[a.prop]},set:function(a){n.fx.step[a.prop]?n.fx.step[a.prop](a):a.elem.style&&(null!=a.elem.style[n.cssProps[a.prop]]||n.cssHooks[a.prop])?n.style(a.elem,a.prop,a.now+a.unit):a.elem[a.prop]=a.now}}},Kb.propHooks.scrollTop=Kb.propHooks.scrollLeft={set:function(a){a.elem.nodeType&&a.elem.parentNode&&(a.elem[a.prop]=a.now)}},n.easing={linear:function(a){return a},swing:function(a){return.5-Math.cos(a*Math.PI)/2}},n.fx=Kb.prototype.init,n.fx.step={};var Lb,Mb,Nb=/^(?:toggle|show|hide)$/,Ob=new RegExp("^(?:([+-])=|)("+Q+")([a-z%]*)$","i"),Pb=/queueHooks$/,Qb=[Vb],Rb={"*":[function(a,b){var c=this.createTween(a,b),d=c.cur(),e=Ob.exec(b),f=e&&e[3]||(n.cssNumber[a]?"":"px"),g=(n.cssNumber[a]||"px"!==f&&+d)&&Ob.exec(n.css(c.elem,a)),h=1,i=20;if(g&&g[3]!==f){f=f||g[3],e=e||[],g=+d||1;do h=h||".5",g/=h,n.style(c.elem,a,g+f);while(h!==(h=c.cur()/d)&&1!==h&&--i)}return e&&(g=c.start=+g||+d||0,c.unit=f,c.end=e[1]?g+(e[1]+1)*e[2]:+e[2]),c}]};function Sb(){return setTimeout(function(){Lb=void 0}),Lb=n.now()}function Tb(a,b){var c,d=0,e={height:a};for(b=b?1:0;4>d;d+=2-b)c=R[d],e["margin"+c]=e["padding"+c]=a;return b&&(e.opacity=e.width=a),e}function Ub(a,b,c){for(var d,e=(Rb[b]||[]).concat(Rb["*"]),f=0,g=e.length;g>f;f++)if(d=e[f].call(c,b,a))return d}function Vb(a,b,c){var d,e,f,g,h,i,j,k,l=this,m={},o=a.style,p=a.nodeType&&S(a),q=L.get(a,"fxshow");c.queue||(h=n._queueHooks(a,"fx"),null==h.unqueued&&(h.unqueued=0,i=h.empty.fire,h.empty.fire=function(){h.unqueued||i()}),h.unqueued++,l.always(function(){l.always(function(){h.unqueued--,n.queue(a,"fx").length||h.empty.fire()})})),1===a.nodeType&&("height"in b||"width"in b)&&(c.overflow=[o.overflow,o.overflowX,o.overflowY],j=n.css(a,"display"),k="none"===j?L.get(a,"olddisplay")||tb(a.nodeName):j,"inline"===k&&"none"===n.css(a,"float")&&(o.display="inline-block")),c.overflow&&(o.overflow="hidden",l.always(function(){o.overflow=c.overflow[0],o.overflowX=c.overflow[1],o.overflowY=c.overflow[2]}));for(d in b)if(e=b[d],Nb.exec(e)){if(delete b[d],f=f||"toggle"===e,e===(p?"hide":"show")){if("show"!==e||!q||void 0===q[d])continue;p=!0}m[d]=q&&q[d]||n.style(a,d)}else j=void 0;if(n.isEmptyObject(m))"inline"===("none"===j?tb(a.nodeName):j)&&(o.display=j);else{q?"hidden"in q&&(p=q.hidden):q=L.access(a,"fxshow",{}),f&&(q.hidden=!p),p?n(a).show():l.done(function(){n(a).hide()}),l.done(function(){var b;L.remove(a,"fxshow");for(b in m)n.style(a,b,m[b])});for(d in m)g=Ub(p?q[d]:0,d,l),d in q||(q[d]=g.start,p&&(g.end=g.start,g.start="width"===d||"height"===d?1:0))}}function Wb(a,b){var c,d,e,f,g;for(c in a)if(d=n.camelCase(c),e=b[d],f=a[c],n.isArray(f)&&(e=f[1],f=a[c]=f[0]),c!==d&&(a[d]=f,delete a[c]),g=n.cssHooks[d],g&&"expand"in g){f=g.expand(f),delete a[d];for(c in f)c in a||(a[c]=f[c],b[c]=e)}else b[d]=e}function Xb(a,b,c){var d,e,f=0,g=Qb.length,h=n.Deferred().always(function(){delete i.elem}),i=function(){if(e)return!1;for(var b=Lb||Sb(),c=Math.max(0,j.startTime+j.duration-b),d=c/j.duration||0,f=1-d,g=0,i=j.tweens.length;i>g;g++)j.tweens[g].run(f);return h.notifyWith(a,[j,f,c]),1>f&&i?c:(h.resolveWith(a,[j]),!1)},j=h.promise({elem:a,props:n.extend({},b),opts:n.extend(!0,{specialEasing:{}},c),originalProperties:b,originalOptions:c,startTime:Lb||Sb(),duration:c.duration,tweens:[],createTween:function(b,c){var d=n.Tween(a,j.opts,b,c,j.opts.specialEasing[b]||j.opts.easing);return j.tweens.push(d),d},stop:function(b){var c=0,d=b?j.tweens.length:0;if(e)return this;for(e=!0;d>c;c++)j.tweens[c].run(1);return b?h.resolveWith(a,[j,b]):h.rejectWith(a,[j,b]),this}}),k=j.props;for(Wb(k,j.opts.specialEasing);g>f;f++)if(d=Qb[f].call(j,a,k,j.opts))return d;return n.map(k,Ub,j),n.isFunction(j.opts.start)&&j.opts.start.call(a,j),n.fx.timer(n.extend(i,{elem:a,anim:j,queue:j.opts.queue})),j.progress(j.opts.progress).done(j.opts.done,j.opts.complete).fail(j.opts.fail).always(j.opts.always)}n.Animation=n.extend(Xb,{tweener:function(a,b){n.isFunction(a)?(b=a,a=["*"]):a=a.split(" ");for(var c,d=0,e=a.length;e>d;d++)c=a[d],Rb[c]=Rb[c]||[],Rb[c].unshift(b)},prefilter:function(a,b){b?Qb.unshift(a):Qb.push(a)}}),n.speed=function(a,b,c){var d=a&&"object"==typeof a?n.extend({},a):{complete:c||!c&&b||n.isFunction(a)&&a,duration:a,easing:c&&b||b&&!n.isFunction(b)&&b};return d.duration=n.fx.off?0:"number"==typeof d.duration?d.duration:d.duration in n.fx.speeds?n.fx.speeds[d.duration]:n.fx.speeds._default,(null==d.queue||d.queue===!0)&&(d.queue="fx"),d.old=d.complete,d.complete=function(){n.isFunction(d.old)&&d.old.call(this),d.queue&&n.dequeue(this,d.queue)},d},n.fn.extend({fadeTo:function(a,b,c,d){return this.filter(S).css("opacity",0).show().end().animate({opacity:b},a,c,d)},animate:function(a,b,c,d){var e=n.isEmptyObject(a),f=n.speed(b,c,d),g=function(){var b=Xb(this,n.extend({},a),f);(e||L.get(this,"finish"))&&b.stop(!0)};return g.finish=g,e||f.queue===!1?this.each(g):this.queue(f.queue,g)},stop:function(a,b,c){var d=function(a){var b=a.stop;delete a.stop,b(c)};return"string"!=typeof a&&(c=b,b=a,a=void 0),b&&a!==!1&&this.queue(a||"fx",[]),this.each(function(){var b=!0,e=null!=a&&a+"queueHooks",f=n.timers,g=L.get(this);if(e)g[e]&&g[e].stop&&d(g[e]);else for(e in g)g[e]&&g[e].stop&&Pb.test(e)&&d(g[e]);for(e=f.length;e--;)f[e].elem!==this||null!=a&&f[e].queue!==a||(f[e].anim.stop(c),b=!1,f.splice(e,1));(b||!c)&&n.dequeue(this,a)})},finish:function(a){return a!==!1&&(a=a||"fx"),this.each(function(){var b,c=L.get(this),d=c[a+"queue"],e=c[a+"queueHooks"],f=n.timers,g=d?d.length:0;for(c.finish=!0,n.queue(this,a,[]),e&&e.stop&&e.stop.call(this,!0),b=f.length;b--;)f[b].elem===this&&f[b].queue===a&&(f[b].anim.stop(!0),f.splice(b,1));for(b=0;g>b;b++)d[b]&&d[b].finish&&d[b].finish.call(this);delete c.finish})}}),n.each(["toggle","show","hide"],function(a,b){var c=n.fn[b];n.fn[b]=function(a,d,e){return null==a||"boolean"==typeof a?c.apply(this,arguments):this.animate(Tb(b,!0),a,d,e)}}),n.each({slideDown:Tb("show"),slideUp:Tb("hide"),slideToggle:Tb("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(a,b){n.fn[a]=function(a,c,d){return this.animate(b,a,c,d)}}),n.timers=[],n.fx.tick=function(){var a,b=0,c=n.timers;for(Lb=n.now();b<c.length;b++)a=c[b],a()||c[b]!==a||c.splice(b--,1);c.length||n.fx.stop(),Lb=void 0},n.fx.timer=function(a){n.timers.push(a),a()?n.fx.start():n.timers.pop()},n.fx.interval=13,n.fx.start=function(){Mb||(Mb=setInterval(n.fx.tick,n.fx.interval))},n.fx.stop=function(){clearInterval(Mb),Mb=null},n.fx.speeds={slow:600,fast:200,_default:400},n.fn.delay=function(a,b){return a=n.fx?n.fx.speeds[a]||a:a,b=b||"fx",this.queue(b,function(b,c){var d=setTimeout(b,a);c.stop=function(){clearTimeout(d)}})},function(){var a=l.createElement("input"),b=l.createElement("select"),c=b.appendChild(l.createElement("option"));a.type="checkbox",k.checkOn=""!==a.value,k.optSelected=c.selected,b.disabled=!0,k.optDisabled=!c.disabled,a=l.createElement("input"),a.value="t",a.type="radio",k.radioValue="t"===a.value}();var Yb,Zb,$b=n.expr.attrHandle;n.fn.extend({attr:function(a,b){return J(this,n.attr,a,b,arguments.length>1)},removeAttr:function(a){return this.each(function(){n.removeAttr(this,a)})}}),n.extend({attr:function(a,b,c){var d,e,f=a.nodeType;if(a&&3!==f&&8!==f&&2!==f)return typeof a.getAttribute===U?n.prop(a,b,c):(1===f&&n.isXMLDoc(a)||(b=b.toLowerCase(),d=n.attrHooks[b]||(n.expr.match.bool.test(b)?Zb:Yb)),void 0===c?d&&"get"in d&&null!==(e=d.get(a,b))?e:(e=n.find.attr(a,b),null==e?void 0:e):null!==c?d&&"set"in d&&void 0!==(e=d.set(a,c,b))?e:(a.setAttribute(b,c+""),c):void n.removeAttr(a,b))
},removeAttr:function(a,b){var c,d,e=0,f=b&&b.match(E);if(f&&1===a.nodeType)while(c=f[e++])d=n.propFix[c]||c,n.expr.match.bool.test(c)&&(a[d]=!1),a.removeAttribute(c)},attrHooks:{type:{set:function(a,b){if(!k.radioValue&&"radio"===b&&n.nodeName(a,"input")){var c=a.value;return a.setAttribute("type",b),c&&(a.value=c),b}}}}}),Zb={set:function(a,b,c){return b===!1?n.removeAttr(a,c):a.setAttribute(c,c),c}},n.each(n.expr.match.bool.source.match(/\w+/g),function(a,b){var c=$b[b]||n.find.attr;$b[b]=function(a,b,d){var e,f;return d||(f=$b[b],$b[b]=e,e=null!=c(a,b,d)?b.toLowerCase():null,$b[b]=f),e}});var _b=/^(?:input|select|textarea|button)$/i;n.fn.extend({prop:function(a,b){return J(this,n.prop,a,b,arguments.length>1)},removeProp:function(a){return this.each(function(){delete this[n.propFix[a]||a]})}}),n.extend({propFix:{"for":"htmlFor","class":"className"},prop:function(a,b,c){var d,e,f,g=a.nodeType;if(a&&3!==g&&8!==g&&2!==g)return f=1!==g||!n.isXMLDoc(a),f&&(b=n.propFix[b]||b,e=n.propHooks[b]),void 0!==c?e&&"set"in e&&void 0!==(d=e.set(a,c,b))?d:a[b]=c:e&&"get"in e&&null!==(d=e.get(a,b))?d:a[b]},propHooks:{tabIndex:{get:function(a){return a.hasAttribute("tabindex")||_b.test(a.nodeName)||a.href?a.tabIndex:-1}}}}),k.optSelected||(n.propHooks.selected={get:function(a){var b=a.parentNode;return b&&b.parentNode&&b.parentNode.selectedIndex,null}}),n.each(["tabIndex","readOnly","maxLength","cellSpacing","cellPadding","rowSpan","colSpan","useMap","frameBorder","contentEditable"],function(){n.propFix[this.toLowerCase()]=this});var ac=/[\t\r\n\f]/g;n.fn.extend({addClass:function(a){var b,c,d,e,f,g,h="string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).addClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ac," "):" ")){f=0;while(e=b[f++])d.indexOf(" "+e+" ")<0&&(d+=e+" ");g=n.trim(d),c.className!==g&&(c.className=g)}return this},removeClass:function(a){var b,c,d,e,f,g,h=0===arguments.length||"string"==typeof a&&a,i=0,j=this.length;if(n.isFunction(a))return this.each(function(b){n(this).removeClass(a.call(this,b,this.className))});if(h)for(b=(a||"").match(E)||[];j>i;i++)if(c=this[i],d=1===c.nodeType&&(c.className?(" "+c.className+" ").replace(ac," "):"")){f=0;while(e=b[f++])while(d.indexOf(" "+e+" ")>=0)d=d.replace(" "+e+" "," ");g=a?n.trim(d):"",c.className!==g&&(c.className=g)}return this},toggleClass:function(a,b){var c=typeof a;return"boolean"==typeof b&&"string"===c?b?this.addClass(a):this.removeClass(a):this.each(n.isFunction(a)?function(c){n(this).toggleClass(a.call(this,c,this.className,b),b)}:function(){if("string"===c){var b,d=0,e=n(this),f=a.match(E)||[];while(b=f[d++])e.hasClass(b)?e.removeClass(b):e.addClass(b)}else(c===U||"boolean"===c)&&(this.className&&L.set(this,"__className__",this.className),this.className=this.className||a===!1?"":L.get(this,"__className__")||"")})},hasClass:function(a){for(var b=" "+a+" ",c=0,d=this.length;d>c;c++)if(1===this[c].nodeType&&(" "+this[c].className+" ").replace(ac," ").indexOf(b)>=0)return!0;return!1}});var bc=/\r/g;n.fn.extend({val:function(a){var b,c,d,e=this[0];{if(arguments.length)return d=n.isFunction(a),this.each(function(c){var e;1===this.nodeType&&(e=d?a.call(this,c,n(this).val()):a,null==e?e="":"number"==typeof e?e+="":n.isArray(e)&&(e=n.map(e,function(a){return null==a?"":a+""})),b=n.valHooks[this.type]||n.valHooks[this.nodeName.toLowerCase()],b&&"set"in b&&void 0!==b.set(this,e,"value")||(this.value=e))});if(e)return b=n.valHooks[e.type]||n.valHooks[e.nodeName.toLowerCase()],b&&"get"in b&&void 0!==(c=b.get(e,"value"))?c:(c=e.value,"string"==typeof c?c.replace(bc,""):null==c?"":c)}}}),n.extend({valHooks:{option:{get:function(a){var b=n.find.attr(a,"value");return null!=b?b:n.trim(n.text(a))}},select:{get:function(a){for(var b,c,d=a.options,e=a.selectedIndex,f="select-one"===a.type||0>e,g=f?null:[],h=f?e+1:d.length,i=0>e?h:f?e:0;h>i;i++)if(c=d[i],!(!c.selected&&i!==e||(k.optDisabled?c.disabled:null!==c.getAttribute("disabled"))||c.parentNode.disabled&&n.nodeName(c.parentNode,"optgroup"))){if(b=n(c).val(),f)return b;g.push(b)}return g},set:function(a,b){var c,d,e=a.options,f=n.makeArray(b),g=e.length;while(g--)d=e[g],(d.selected=n.inArray(d.value,f)>=0)&&(c=!0);return c||(a.selectedIndex=-1),f}}}}),n.each(["radio","checkbox"],function(){n.valHooks[this]={set:function(a,b){return n.isArray(b)?a.checked=n.inArray(n(a).val(),b)>=0:void 0}},k.checkOn||(n.valHooks[this].get=function(a){return null===a.getAttribute("value")?"on":a.value})}),n.each("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu".split(" "),function(a,b){n.fn[b]=function(a,c){return arguments.length>0?this.on(b,null,a,c):this.trigger(b)}}),n.fn.extend({hover:function(a,b){return this.mouseenter(a).mouseleave(b||a)},bind:function(a,b,c){return this.on(a,null,b,c)},unbind:function(a,b){return this.off(a,null,b)},delegate:function(a,b,c,d){return this.on(b,a,c,d)},undelegate:function(a,b,c){return 1===arguments.length?this.off(a,"**"):this.off(b,a||"**",c)}});var cc=n.now(),dc=/\?/;n.parseJSON=function(a){return JSON.parse(a+"")},n.parseXML=function(a){var b,c;if(!a||"string"!=typeof a)return null;try{c=new DOMParser,b=c.parseFromString(a,"text/xml")}catch(d){b=void 0}return(!b||b.getElementsByTagName("parsererror").length)&&n.error("Invalid XML: "+a),b};var ec,fc,gc=/#.*$/,hc=/([?&])_=[^&]*/,ic=/^(.*?):[ \t]*([^\r\n]*)$/gm,jc=/^(?:about|app|app-storage|.+-extension|file|res|widget):$/,kc=/^(?:GET|HEAD)$/,lc=/^\/\//,mc=/^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/,nc={},oc={},pc="*/".concat("*");try{fc=location.href}catch(qc){fc=l.createElement("a"),fc.href="",fc=fc.href}ec=mc.exec(fc.toLowerCase())||[];function rc(a){return function(b,c){"string"!=typeof b&&(c=b,b="*");var d,e=0,f=b.toLowerCase().match(E)||[];if(n.isFunction(c))while(d=f[e++])"+"===d[0]?(d=d.slice(1)||"*",(a[d]=a[d]||[]).unshift(c)):(a[d]=a[d]||[]).push(c)}}function sc(a,b,c,d){var e={},f=a===oc;function g(h){var i;return e[h]=!0,n.each(a[h]||[],function(a,h){var j=h(b,c,d);return"string"!=typeof j||f||e[j]?f?!(i=j):void 0:(b.dataTypes.unshift(j),g(j),!1)}),i}return g(b.dataTypes[0])||!e["*"]&&g("*")}function tc(a,b){var c,d,e=n.ajaxSettings.flatOptions||{};for(c in b)void 0!==b[c]&&((e[c]?a:d||(d={}))[c]=b[c]);return d&&n.extend(!0,a,d),a}function uc(a,b,c){var d,e,f,g,h=a.contents,i=a.dataTypes;while("*"===i[0])i.shift(),void 0===d&&(d=a.mimeType||b.getResponseHeader("Content-Type"));if(d)for(e in h)if(h[e]&&h[e].test(d)){i.unshift(e);break}if(i[0]in c)f=i[0];else{for(e in c){if(!i[0]||a.converters[e+" "+i[0]]){f=e;break}g||(g=e)}f=f||g}return f?(f!==i[0]&&i.unshift(f),c[f]):void 0}function vc(a,b,c,d){var e,f,g,h,i,j={},k=a.dataTypes.slice();if(k[1])for(g in a.converters)j[g.toLowerCase()]=a.converters[g];f=k.shift();while(f)if(a.responseFields[f]&&(c[a.responseFields[f]]=b),!i&&d&&a.dataFilter&&(b=a.dataFilter(b,a.dataType)),i=f,f=k.shift())if("*"===f)f=i;else if("*"!==i&&i!==f){if(g=j[i+" "+f]||j["* "+f],!g)for(e in j)if(h=e.split(" "),h[1]===f&&(g=j[i+" "+h[0]]||j["* "+h[0]])){g===!0?g=j[e]:j[e]!==!0&&(f=h[0],k.unshift(h[1]));break}if(g!==!0)if(g&&a["throws"])b=g(b);else try{b=g(b)}catch(l){return{state:"parsererror",error:g?l:"No conversion from "+i+" to "+f}}}return{state:"success",data:b}}n.extend({active:0,lastModified:{},etag:{},ajaxSettings:{url:fc,type:"GET",isLocal:jc.test(ec[1]),global:!0,processData:!0,async:!0,contentType:"application/x-www-form-urlencoded; charset=UTF-8",accepts:{"*":pc,text:"text/plain",html:"text/html",xml:"application/xml, text/xml",json:"application/json, text/javascript"},contents:{xml:/xml/,html:/html/,json:/json/},responseFields:{xml:"responseXML",text:"responseText",json:"responseJSON"},converters:{"* text":String,"text html":!0,"text json":n.parseJSON,"text xml":n.parseXML},flatOptions:{url:!0,context:!0}},ajaxSetup:function(a,b){return b?tc(tc(a,n.ajaxSettings),b):tc(n.ajaxSettings,a)},ajaxPrefilter:rc(nc),ajaxTransport:rc(oc),ajax:function(a,b){"object"==typeof a&&(b=a,a=void 0),b=b||{};var c,d,e,f,g,h,i,j,k=n.ajaxSetup({},b),l=k.context||k,m=k.context&&(l.nodeType||l.jquery)?n(l):n.event,o=n.Deferred(),p=n.Callbacks("once memory"),q=k.statusCode||{},r={},s={},t=0,u="canceled",v={readyState:0,getResponseHeader:function(a){var b;if(2===t){if(!f){f={};while(b=ic.exec(e))f[b[1].toLowerCase()]=b[2]}b=f[a.toLowerCase()]}return null==b?null:b},getAllResponseHeaders:function(){return 2===t?e:null},setRequestHeader:function(a,b){var c=a.toLowerCase();return t||(a=s[c]=s[c]||a,r[a]=b),this},overrideMimeType:function(a){return t||(k.mimeType=a),this},statusCode:function(a){var b;if(a)if(2>t)for(b in a)q[b]=[q[b],a[b]];else v.always(a[v.status]);return this},abort:function(a){var b=a||u;return c&&c.abort(b),x(0,b),this}};if(o.promise(v).complete=p.add,v.success=v.done,v.error=v.fail,k.url=((a||k.url||fc)+"").replace(gc,"").replace(lc,ec[1]+"//"),k.type=b.method||b.type||k.method||k.type,k.dataTypes=n.trim(k.dataType||"*").toLowerCase().match(E)||[""],null==k.crossDomain&&(h=mc.exec(k.url.toLowerCase()),k.crossDomain=!(!h||h[1]===ec[1]&&h[2]===ec[2]&&(h[3]||("http:"===h[1]?"80":"443"))===(ec[3]||("http:"===ec[1]?"80":"443")))),k.data&&k.processData&&"string"!=typeof k.data&&(k.data=n.param(k.data,k.traditional)),sc(nc,k,b,v),2===t)return v;i=k.global,i&&0===n.active++&&n.event.trigger("ajaxStart"),k.type=k.type.toUpperCase(),k.hasContent=!kc.test(k.type),d=k.url,k.hasContent||(k.data&&(d=k.url+=(dc.test(d)?"&":"?")+k.data,delete k.data),k.cache===!1&&(k.url=hc.test(d)?d.replace(hc,"$1_="+cc++):d+(dc.test(d)?"&":"?")+"_="+cc++)),k.ifModified&&(n.lastModified[d]&&v.setRequestHeader("If-Modified-Since",n.lastModified[d]),n.etag[d]&&v.setRequestHeader("If-None-Match",n.etag[d])),(k.data&&k.hasContent&&k.contentType!==!1||b.contentType)&&v.setRequestHeader("Content-Type",k.contentType),v.setRequestHeader("Accept",k.dataTypes[0]&&k.accepts[k.dataTypes[0]]?k.accepts[k.dataTypes[0]]+("*"!==k.dataTypes[0]?", "+pc+"; q=0.01":""):k.accepts["*"]);for(j in k.headers)v.setRequestHeader(j,k.headers[j]);if(k.beforeSend&&(k.beforeSend.call(l,v,k)===!1||2===t))return v.abort();u="abort";for(j in{success:1,error:1,complete:1})v[j](k[j]);if(c=sc(oc,k,b,v)){v.readyState=1,i&&m.trigger("ajaxSend",[v,k]),k.async&&k.timeout>0&&(g=setTimeout(function(){v.abort("timeout")},k.timeout));try{t=1,c.send(r,x)}catch(w){if(!(2>t))throw w;x(-1,w)}}else x(-1,"No Transport");function x(a,b,f,h){var j,r,s,u,w,x=b;2!==t&&(t=2,g&&clearTimeout(g),c=void 0,e=h||"",v.readyState=a>0?4:0,j=a>=200&&300>a||304===a,f&&(u=uc(k,v,f)),u=vc(k,u,v,j),j?(k.ifModified&&(w=v.getResponseHeader("Last-Modified"),w&&(n.lastModified[d]=w),w=v.getResponseHeader("etag"),w&&(n.etag[d]=w)),204===a||"HEAD"===k.type?x="nocontent":304===a?x="notmodified":(x=u.state,r=u.data,s=u.error,j=!s)):(s=x,(a||!x)&&(x="error",0>a&&(a=0))),v.status=a,v.statusText=(b||x)+"",j?o.resolveWith(l,[r,x,v]):o.rejectWith(l,[v,x,s]),v.statusCode(q),q=void 0,i&&m.trigger(j?"ajaxSuccess":"ajaxError",[v,k,j?r:s]),p.fireWith(l,[v,x]),i&&(m.trigger("ajaxComplete",[v,k]),--n.active||n.event.trigger("ajaxStop")))}return v},getJSON:function(a,b,c){return n.get(a,b,c,"json")},getScript:function(a,b){return n.get(a,void 0,b,"script")}}),n.each(["get","post"],function(a,b){n[b]=function(a,c,d,e){return n.isFunction(c)&&(e=e||d,d=c,c=void 0),n.ajax({url:a,type:b,dataType:e,data:c,success:d})}}),n.each(["ajaxStart","ajaxStop","ajaxComplete","ajaxError","ajaxSuccess","ajaxSend"],function(a,b){n.fn[b]=function(a){return this.on(b,a)}}),n._evalUrl=function(a){return n.ajax({url:a,type:"GET",dataType:"script",async:!1,global:!1,"throws":!0})},n.fn.extend({wrapAll:function(a){var b;return n.isFunction(a)?this.each(function(b){n(this).wrapAll(a.call(this,b))}):(this[0]&&(b=n(a,this[0].ownerDocument).eq(0).clone(!0),this[0].parentNode&&b.insertBefore(this[0]),b.map(function(){var a=this;while(a.firstElementChild)a=a.firstElementChild;return a}).append(this)),this)},wrapInner:function(a){return this.each(n.isFunction(a)?function(b){n(this).wrapInner(a.call(this,b))}:function(){var b=n(this),c=b.contents();c.length?c.wrapAll(a):b.append(a)})},wrap:function(a){var b=n.isFunction(a);return this.each(function(c){n(this).wrapAll(b?a.call(this,c):a)})},unwrap:function(){return this.parent().each(function(){n.nodeName(this,"body")||n(this).replaceWith(this.childNodes)}).end()}}),n.expr.filters.hidden=function(a){return a.offsetWidth<=0&&a.offsetHeight<=0},n.expr.filters.visible=function(a){return!n.expr.filters.hidden(a)};var wc=/%20/g,xc=/\[\]$/,yc=/\r?\n/g,zc=/^(?:submit|button|image|reset|file)$/i,Ac=/^(?:input|select|textarea|keygen)/i;function Bc(a,b,c,d){var e;if(n.isArray(b))n.each(b,function(b,e){c||xc.test(a)?d(a,e):Bc(a+"["+("object"==typeof e?b:"")+"]",e,c,d)});else if(c||"object"!==n.type(b))d(a,b);else for(e in b)Bc(a+"["+e+"]",b[e],c,d)}n.param=function(a,b){var c,d=[],e=function(a,b){b=n.isFunction(b)?b():null==b?"":b,d[d.length]=encodeURIComponent(a)+"="+encodeURIComponent(b)};if(void 0===b&&(b=n.ajaxSettings&&n.ajaxSettings.traditional),n.isArray(a)||a.jquery&&!n.isPlainObject(a))n.each(a,function(){e(this.name,this.value)});else for(c in a)Bc(c,a[c],b,e);return d.join("&").replace(wc,"+")},n.fn.extend({serialize:function(){return n.param(this.serializeArray())},serializeArray:function(){return this.map(function(){var a=n.prop(this,"elements");return a?n.makeArray(a):this}).filter(function(){var a=this.type;return this.name&&!n(this).is(":disabled")&&Ac.test(this.nodeName)&&!zc.test(a)&&(this.checked||!T.test(a))}).map(function(a,b){var c=n(this).val();return null==c?null:n.isArray(c)?n.map(c,function(a){return{name:b.name,value:a.replace(yc,"\r\n")}}):{name:b.name,value:c.replace(yc,"\r\n")}}).get()}}),n.ajaxSettings.xhr=function(){try{return new XMLHttpRequest}catch(a){}};var Cc=0,Dc={},Ec={0:200,1223:204},Fc=n.ajaxSettings.xhr();a.ActiveXObject&&n(a).on("unload",function(){for(var a in Dc)Dc[a]()}),k.cors=!!Fc&&"withCredentials"in Fc,k.ajax=Fc=!!Fc,n.ajaxTransport(function(a){var b;return k.cors||Fc&&!a.crossDomain?{send:function(c,d){var e,f=a.xhr(),g=++Cc;if(f.open(a.type,a.url,a.async,a.username,a.password),a.xhrFields)for(e in a.xhrFields)f[e]=a.xhrFields[e];a.mimeType&&f.overrideMimeType&&f.overrideMimeType(a.mimeType),a.crossDomain||c["X-Requested-With"]||(c["X-Requested-With"]="XMLHttpRequest");for(e in c)f.setRequestHeader(e,c[e]);b=function(a){return function(){b&&(delete Dc[g],b=f.onload=f.onerror=null,"abort"===a?f.abort():"error"===a?d(f.status,f.statusText):d(Ec[f.status]||f.status,f.statusText,"string"==typeof f.responseText?{text:f.responseText}:void 0,f.getAllResponseHeaders()))}},f.onload=b(),f.onerror=b("error"),b=Dc[g]=b("abort");try{f.send(a.hasContent&&a.data||null)}catch(h){if(b)throw h}},abort:function(){b&&b()}}:void 0}),n.ajaxSetup({accepts:{script:"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},contents:{script:/(?:java|ecma)script/},converters:{"text script":function(a){return n.globalEval(a),a}}}),n.ajaxPrefilter("script",function(a){void 0===a.cache&&(a.cache=!1),a.crossDomain&&(a.type="GET")}),n.ajaxTransport("script",function(a){if(a.crossDomain){var b,c;return{send:function(d,e){b=n("<script>").prop({async:!0,charset:a.scriptCharset,src:a.url}).on("load error",c=function(a){b.remove(),c=null,a&&e("error"===a.type?404:200,a.type)}),l.head.appendChild(b[0])},abort:function(){c&&c()}}}});var Gc=[],Hc=/(=)\?(?=&|$)|\?\?/;n.ajaxSetup({jsonp:"callback",jsonpCallback:function(){var a=Gc.pop()||n.expando+"_"+cc++;return this[a]=!0,a}}),n.ajaxPrefilter("json jsonp",function(b,c,d){var e,f,g,h=b.jsonp!==!1&&(Hc.test(b.url)?"url":"string"==typeof b.data&&!(b.contentType||"").indexOf("application/x-www-form-urlencoded")&&Hc.test(b.data)&&"data");return h||"jsonp"===b.dataTypes[0]?(e=b.jsonpCallback=n.isFunction(b.jsonpCallback)?b.jsonpCallback():b.jsonpCallback,h?b[h]=b[h].replace(Hc,"$1"+e):b.jsonp!==!1&&(b.url+=(dc.test(b.url)?"&":"?")+b.jsonp+"="+e),b.converters["script json"]=function(){return g||n.error(e+" was not called"),g[0]},b.dataTypes[0]="json",f=a[e],a[e]=function(){g=arguments},d.always(function(){a[e]=f,b[e]&&(b.jsonpCallback=c.jsonpCallback,Gc.push(e)),g&&n.isFunction(f)&&f(g[0]),g=f=void 0}),"script"):void 0}),n.parseHTML=function(a,b,c){if(!a||"string"!=typeof a)return null;"boolean"==typeof b&&(c=b,b=!1),b=b||l;var d=v.exec(a),e=!c&&[];return d?[b.createElement(d[1])]:(d=n.buildFragment([a],b,e),e&&e.length&&n(e).remove(),n.merge([],d.childNodes))};var Ic=n.fn.load;n.fn.load=function(a,b,c){if("string"!=typeof a&&Ic)return Ic.apply(this,arguments);var d,e,f,g=this,h=a.indexOf(" ");return h>=0&&(d=n.trim(a.slice(h)),a=a.slice(0,h)),n.isFunction(b)?(c=b,b=void 0):b&&"object"==typeof b&&(e="POST"),g.length>0&&n.ajax({url:a,type:e,dataType:"html",data:b}).done(function(a){f=arguments,g.html(d?n("<div>").append(n.parseHTML(a)).find(d):a)}).complete(c&&function(a,b){g.each(c,f||[a.responseText,b,a])}),this},n.expr.filters.animated=function(a){return n.grep(n.timers,function(b){return a===b.elem}).length};var Jc=a.document.documentElement;function Kc(a){return n.isWindow(a)?a:9===a.nodeType&&a.defaultView}n.offset={setOffset:function(a,b,c){var d,e,f,g,h,i,j,k=n.css(a,"position"),l=n(a),m={};"static"===k&&(a.style.position="relative"),h=l.offset(),f=n.css(a,"top"),i=n.css(a,"left"),j=("absolute"===k||"fixed"===k)&&(f+i).indexOf("auto")>-1,j?(d=l.position(),g=d.top,e=d.left):(g=parseFloat(f)||0,e=parseFloat(i)||0),n.isFunction(b)&&(b=b.call(a,c,h)),null!=b.top&&(m.top=b.top-h.top+g),null!=b.left&&(m.left=b.left-h.left+e),"using"in b?b.using.call(a,m):l.css(m)}},n.fn.extend({offset:function(a){if(arguments.length)return void 0===a?this:this.each(function(b){n.offset.setOffset(this,a,b)});var b,c,d=this[0],e={top:0,left:0},f=d&&d.ownerDocument;if(f)return b=f.documentElement,n.contains(b,d)?(typeof d.getBoundingClientRect!==U&&(e=d.getBoundingClientRect()),c=Kc(f),{top:e.top+c.pageYOffset-b.clientTop,left:e.left+c.pageXOffset-b.clientLeft}):e},position:function(){if(this[0]){var a,b,c=this[0],d={top:0,left:0};return"fixed"===n.css(c,"position")?b=c.getBoundingClientRect():(a=this.offsetParent(),b=this.offset(),n.nodeName(a[0],"html")||(d=a.offset()),d.top+=n.css(a[0],"borderTopWidth",!0),d.left+=n.css(a[0],"borderLeftWidth",!0)),{top:b.top-d.top-n.css(c,"marginTop",!0),left:b.left-d.left-n.css(c,"marginLeft",!0)}}},offsetParent:function(){return this.map(function(){var a=this.offsetParent||Jc;while(a&&!n.nodeName(a,"html")&&"static"===n.css(a,"position"))a=a.offsetParent;return a||Jc})}}),n.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(b,c){var d="pageYOffset"===c;n.fn[b]=function(e){return J(this,function(b,e,f){var g=Kc(b);return void 0===f?g?g[c]:b[e]:void(g?g.scrollTo(d?a.pageXOffset:f,d?f:a.pageYOffset):b[e]=f)},b,e,arguments.length,null)}}),n.each(["top","left"],function(a,b){n.cssHooks[b]=yb(k.pixelPosition,function(a,c){return c?(c=xb(a,b),vb.test(c)?n(a).position()[b]+"px":c):void 0})}),n.each({Height:"height",Width:"width"},function(a,b){n.each({padding:"inner"+a,content:b,"":"outer"+a},function(c,d){n.fn[d]=function(d,e){var f=arguments.length&&(c||"boolean"!=typeof d),g=c||(d===!0||e===!0?"margin":"border");return J(this,function(b,c,d){var e;return n.isWindow(b)?b.document.documentElement["client"+a]:9===b.nodeType?(e=b.documentElement,Math.max(b.body["scroll"+a],e["scroll"+a],b.body["offset"+a],e["offset"+a],e["client"+a])):void 0===d?n.css(b,c,g):n.style(b,c,d,g)},b,f?d:void 0,f,null)}})}),n.fn.size=function(){return this.length},n.fn.andSelf=n.fn.addBack,"function"==typeof define&&define.amd&&define("jquery",[],function(){return n});var Lc=a.jQuery,Mc=a.$;return n.noConflict=function(b){return a.$===n&&(a.$=Mc),b&&a.jQuery===n&&(a.jQuery=Lc),n},typeof b===U&&(a.jQuery=a.$=n),n});</script>
<script>((exports) => {

    function E(nodeName, attrs) {
        const el = document.createElement(nodeName);
        if (attrs) {
            for (const key in attrs) {
                if (key === "class") {
                    el.className = attrs[key];
                } else {
                    el.setAttribute(key, attrs[key]);
                }
            }
        }
        return el;
    }
    
    let uid_counter = 0;
    function uid() {
        // make id from counter (guaranteeing page-local uniqueness)
        // and random base 36 number (making it look random, so there's no temptation to use it as a sequence)
        // Note: Math.random().toString(36).slice(2) can give empty string
        return (uid_counter++).toString(36) + Math.random().toString(36).slice(2);
    }
    
    // @TODO: DRY hotkey helpers with jspaint (export them?)
    
    // & defines accelerators (hotkeys) in menus and buttons and things, which get underlined in the UI.
    // & can be escaped by doubling it, e.g. "&Taskbar && Start Menu"
    function index_of_hotkey(text) {
        // Returns the index of the ampersand that defines a hotkey, or -1 if not present.
    
        // return english_text.search(/(?<!&)&(?!&|\s)/); // not enough browser support for negative lookbehind assertions
    
        // The space here handles beginning-of-string matching and counteracts the offset for the [^&] so it acts like a negative lookbehind
        return ` ${text}`.search(/[^&]&[^&\s]/);
    }
    // function has_hotkey(text) {
    // 	return index_of_hotkey(text) !== -1;
    // }
    function remove_hotkey(text) {
        return text.replace(/\s?\(&.\)/, "").replace(/([^&]|^)&([^&\s])/, "$1$2");
    }
    function display_hotkey(text) {
        // TODO: use a more general term like .hotkey or .accelerator?
        return text.replace(/([^&]|^)&([^&\s])/, "$1<span class='menu-hotkey'>$2</span>").replace(/&&/g, "&");
    }
    function get_hotkey(text) {
        return text[index_of_hotkey(text) + 1].toUpperCase();
    }
    
    // TODO: support copy/pasting text in the text tool textarea from the menus
    // probably by recording document.activeElement on pointer down,
    // and restoring focus before executing menu item actions.
    
    const MENU_DIVIDER = "MENU_DIVIDER";
    
    const MAX_MENU_NESTING = 1000;
    
    let internal_z_counter = 1;
    function get_new_menu_z_index() {
        // integrate with the OS window z-indexes, if applicable
        // but don't depend on $Window existing, the modules should be independent
        if (typeof $Window !== "undefined") {
            return ($Window.Z_INDEX++) + MAX_MENU_NESTING; // MAX_MENU_NESTING is needed because the window gets brought to the top
        }
        return (++internal_z_counter) + MAX_MENU_NESTING;
    }
    
    function MenuBar(menus) {
        if (!(this instanceof MenuBar)) {
            return new MenuBar(menus);
        }
    
        const menus_el = E("div", {
            class: "menus",
            role: "menubar",
            "aria-label": "Application Menu",
        });
        menus_el.style.touchAction = "none";
    
        // returns writing/layout direction, "ltr" or "rtl"
        function get_direction() {
            return window.get_direction ? window.get_direction() : getComputedStyle(menus_el).direction;
        }
    
        let selecting_menus = false; // state where you can glide between menus without clicking
    
        const top_level_menus = [];
        let top_level_menu_index = -1; // index of the top level menu that's most recently open
        let active_menu_popup; // most nested open MenuPopup
        const menu_popup_by_el = new WeakMap(); // maps DOM elements to MenuPopup instances
    
        // There can be multiple menu bars instantiated from the same menu definitions,
        // so this can't be a map of menu item to submenu, it has to be of menu item ELEMENTS to submenu.
        // (or you know, it could work totally differently, this is just one way obviously)
        // This is for entering submenus.
        const submenu_popups_by_menu_item_el = new WeakMap();
    
        // This is for exiting submenus.
        const parent_item_el_by_popup_el = new WeakMap();
    
        // @TODO: specific to this menu bar (note that popups are not descendants of the menu bar)
        const any_open_menus = () => [...document.querySelectorAll(".menu-popup")].some(popup_el => popup_el.style.display !== "none");
    
        const close_menus = () => {
            for (const { menu_button_el } of top_level_menus) {
                menu_button_el.dispatchEvent(new CustomEvent("release"), {});
            }
            // Close any rogue floating submenus
            // @TODO: eventually this code should be removed
            // it's here pretty much "just in case"
            const popup_els = document.querySelectorAll(".menu-popup");
            for (const popup_el of popup_els) {
                if (!window.debugKeepMenusOpen) {
                    popup_el.style.display = "none";
                    popup_el.querySelectorAll(".menu-item").forEach((el) => el.classList.remove("highlight"));
                    popup_el.removeAttribute("aria-activedescendant");
                    const parent_item_el = parent_item_el_by_popup_el.get(popup_el);
                    if (parent_item_el) {
                        if (!parent_item_el.classList.contains("menu-button")) {
                            parent_item_el.classList.remove("highlight");
                        }
                        parent_item_el.setAttribute("aria-expanded", "false");
                    }
                }
            }
        };
    
        const refocus_window = () => {
            const window_el = menus_el.closest(".window");
            if (window_el) {
                window_el.dispatchEvent(new CustomEvent("refocus-window"));
            }
        };
    
        const top_level_highlight = (new_index_or_menu_key) => {
            const new_index = typeof new_index_or_menu_key === "string" ?
                Object.keys(menus).indexOf(new_index_or_menu_key) :
                new_index_or_menu_key;
            if (top_level_menu_index !== -1) {
                top_level_menus[top_level_menu_index].menu_button_el.classList.remove("highlight");
                // could close the menu here, but it's handled externally right now
            }
            if (new_index !== -1) {
                top_level_menus[new_index].menu_button_el.classList.add("highlight");
            }
            top_level_menu_index = new_index;
        };
        menus_el.addEventListener("pointerleave", () => {
            // unhighlight unless a menu is open
            if (
                top_level_menu_index !== -1 &&
                top_level_menus[top_level_menu_index].menu_popup_el.style.display === "none"
            ) {
                top_level_highlight(-1);
            }
        });
        window.addEventListener("focusout", (event) => {
            // if not still in menus, unhighlight (e.g. if you hit Escape to unfocus the menus)
            if (event.relatedTarget?.closest?.(".menu-popup, .menus")) {
                return;
            }
            top_level_highlight(-1);
        });
    
    
        const is_disabled = item => {
            if (typeof item.enabled === "function") {
                return !item.enabled();
            } else if (typeof item.enabled === "boolean") {
                return !item.enabled;
            } else {
                return false;
            }
        };
    
        function send_info_event(item) {
            // @TODO: in a future version, give the whole menu item definition (or null)
            const description = item?.description || "";
            if (window.jQuery) {
                // old API (using jQuery's "extraParameters"), made forwards compatible with new API (event.detail)
                const event = new window.jQuery.Event("info", { detail: { description } });
                const extraParam = {
                    toString() {
                        console.warn("jQuery extra parameter for info event is deprecated, use event.detail instead");
                        return description;
                    },
                };
                window.jQuery(menus_el).trigger(event, extraParam);
            } else {
                menus_el.dispatchEvent(new CustomEvent("info", { detail: { description } }));
            }
        }
    
    
        // attached to menu bar and floating popups (which are not descendants of the menu bar)
        function handleKeyDown(e) {
            if (e.defaultPrevented) {
                return;
            }
            const active_menu_popup_el = e.target.closest(".menu-popup");
            const active_menu_popup = active_menu_popup_el && menu_popup_by_el.get(active_menu_popup_el);
            const top_level_menu = top_level_menus[top_level_menu_index];
            const { menu_button_el, open_top_level_menu } = top_level_menu || {};
            const menu_popup_el = active_menu_popup_el || top_level_menu?.menu_popup_el;
            const parent_item_el = parent_item_el_by_popup_el.get(active_menu_popup_el);
            const highlighted_item_el = menu_popup_el?.querySelector(".menu-item.highlight");
    
            // console.log("keydown", e.key, { target: e.target, active_menu_popup_el, top_level_menu, menu_popup_el, parent_item_el, highlighted_item_el });
    
            switch (e.keyCode) {
                case 37: // Left
                case 39: // Right
                    const right = e.keyCode === 39;
                    if (
                        highlighted_item_el?.classList.contains("has-submenu") &&
                        (get_direction() === "ltr") === right
                    ) {
                        // enter submenu
                        highlighted_item_el.click();
                        e.preventDefault();
                    } else if (
                        parent_item_el &&
                        !parent_item_el.classList.contains("menu-button") && // left/right doesn't make sense to close the top level menu
                        (get_direction() === "ltr") !== right
                    ) {
                        // exit submenu
                        active_menu_popup.parentMenuPopup.element.focus({ preventScroll: true });
                        active_menu_popup_el.style.display = "none";
                        active_menu_popup.highlight(-1);
                        parent_item_el.setAttribute("aria-expanded", "false");
                        send_info_event(active_menu_popup.parentMenuPopup.menuItems[active_menu_popup.parentMenuPopup.itemElements.indexOf(parent_item_el)]);
                        // @TODO: simplify with something like active_menu_popup.close()
                        e.preventDefault();
                    } else if (
                        // basically any case except if you hover to open a submenu and then press right/left
                        // in which case the menu is already open/focused
                        highlighted_item_el ||
                        !active_menu_popup ||
                        !active_menu_popup.parentMenuPopup
                    ) {
                        // go to next/previous top level menu, wrapping around
                        // and open a new menu only if a menu was already open
                        const menu_was_open = menu_popup_el && menu_popup_el.style.display !== "none";
                        const cycle_dir = ((get_direction() === "ltr") === right) ? 1 : -1;
                        let new_index;
                        if (top_level_menu_index === -1) {
                            new_index = cycle_dir === 1 ? 0 : top_level_menus.length - 1;
                        } else {
                            new_index = (top_level_menu_index + cycle_dir + top_level_menus.length) % top_level_menus.length;
                        }
                        const new_top_level_menu = top_level_menus[new_index];
                        const target_button_el = new_top_level_menu.menu_button_el;
                        if (menu_was_open) {
                            new_top_level_menu.open_top_level_menu("keydown");
                        } else {
                            menu_button_el?.dispatchEvent(new CustomEvent("release"), {});
                            target_button_el.focus({ preventScroll: true });
                            // Note case where menu is closed, menu button is hovered, then menu bar is unhovered,
                            // rehovered(outside any buttons), and unhovered, and THEN you try to go to the next menu.
                            top_level_highlight(new_index);
                        }
                        e.preventDefault();
                    } // else:
                    // if there's no highlighted item, the user may be expecting to enter the menu even though it's already open,
                    // so it makes sense to do nothing (as Windows 98 does) and not go to the next/previous menu
                    // (although highlighting the first item might be nicer...)
                    break;
                case 40: // Down
                case 38: // Up
                    const down = e.keyCode === 40;
                    // if (menu_popup_el && menu_popup_el.style.display !== "none") && highlighted_item_el) {
                    if (active_menu_popup) {
                        const cycle_dir = down ? 1 : -1;
                        const item_els = [...menu_popup_el.querySelectorAll(".menu-item")];
                        const from_index = item_els.indexOf(highlighted_item_el);
                        const to_index = (from_index + cycle_dir + item_els.length) % item_els.length;
                        const to_item_el = item_els[to_index];
                        // active_menu_popup.highlight(to_index); // wouldn't work because it doesn't include separators
                        active_menu_popup.highlight(to_item_el);
                        send_info_event(active_menu_popup.menuItems[active_menu_popup.itemElements.indexOf(to_item_el)]);
                        e.preventDefault();
                    } else {
                        open_top_level_menu?.("keydown");
                    }
                    e.preventDefault();
                    break;
                case 27: // Escape
                    if (any_open_menus()) {
                        // (@TODO: doesn't parent_item_el always exist?)
                        if (parent_item_el && parent_item_el !== menu_button_el) {
                            // exit submenu (@TODO: DRY)
                            active_menu_popup.parentMenuPopup.element.focus({ preventScroll: true });
                            active_menu_popup_el.style.display = "none";
                            active_menu_popup.highlight(-1);
                            parent_item_el.setAttribute("aria-expanded", "false");
                            send_info_event(active_menu_popup.parentMenuPopup.menuItems[active_menu_popup.parentMenuPopup.itemElements.indexOf(parent_item_el)]);
                        } else {
                            // close_menus takes care of releasing the pressed state of the button as well
                            close_menus();
                            menu_button_el.focus({ preventScroll: true });
                        }
                        e.preventDefault();
                    } else {
                        const window_el = menus_el.closest(".window");
                        if (window_el) {
                            // refocus last focused control in window
                            // refocus-window should never focus the menu bar
                            // it stores the last focused control in the window and specifically not in the menus
                            window_el.dispatchEvent(new CustomEvent("refocus-window"));
                            e.preventDefault();
                        }
                    }
                    break;
                case 18: // Alt
                    // close all menus and refocus the last focused control in the window
                    close_menus();
                    refocus_window();
                    e.preventDefault();
                    break;
                case 32: // Space
                    // opens system menu in Windows 98
                    // (at top level)
                    break;
                case 13: // Enter
                    if (menu_button_el === document.activeElement) {
                        open_top_level_menu("keydown");
                        e.preventDefault();
                    } else {
                        highlighted_item_el?.click();
                        e.preventDefault();
                    }
                    break;
                default:
                    // handle accelerators and first-letter navigation
                    const key = String.fromCharCode(e.keyCode).toLowerCase();
                    const item_els = active_menu_popup ?
                        [...menu_popup_el.querySelectorAll(".menu-item")] :
                        top_level_menus.map(top_level_menu => top_level_menu.menu_button_el);
                    const item_els_by_accelerator = {};
                    for (const item_el of item_els) {
                        const accelerator = item_el.querySelector(".menu-hotkey");
                        const accelerator_key = (accelerator ?
                            accelerator.textContent :
                            (item_el.querySelector(".menu-item-label") ?? item_el).textContent[0]
                        ).toLowerCase();
                        item_els_by_accelerator[accelerator_key] = item_els_by_accelerator[accelerator_key] || [];
                        item_els_by_accelerator[accelerator_key].push(item_el);
                    }
                    const matching_item_els = item_els_by_accelerator[key] || [];
                    // console.log({ key, item_els, item_els_by_accelerator, matching_item_els });
                    if (matching_item_els.length) {
                        if (matching_item_els.length === 1) {
                            // it's unambiguous, go ahead and activate it
                            const menu_item_el = matching_item_els[0];
                            // click() doesn't work for menu buttons at the moment,
                            // and also we want to highlight the first item in the menu
                            // in that case, which doesn't happen with the mouse
                            if (menu_item_el.classList.contains("menu-button")) {
                                const top_level_menu = top_level_menus.find(top_level_menu => top_level_menu.menu_button_el === menu_item_el);
                                top_level_menu.open_top_level_menu("keydown");
                            } else {
                                menu_item_el.click();
                            }
                            e.preventDefault();
                        } else {
                            // cycle the menu items that match the key
                            let index = matching_item_els.indexOf(highlighted_item_el);
                            if (index === -1) {
                                index = 0;
                            } else {
                                index = (index + 1) % matching_item_els.length;
                            }
                            const menu_item_el = matching_item_els[index];
                            // active_menu_popup.highlight(index); // would very much not work
                            active_menu_popup.highlight(menu_item_el);
                            e.preventDefault();
                        }
                    }
                    break;
            }
        }
    
        menus_el.addEventListener("keydown", handleKeyDown);
    
        // TODO: API for context menus (i.e. floating menu popups)
        function MenuPopup(menu_items, { parentMenuPopup } = {}) {
            this.parentMenuPopup = parentMenuPopup;
            this.menuItems = menu_items;
            this.itemElements = []; // one-to-one with menuItems (note: not all itemElements have class .menu-item) (@TODO: unify terminology)
    
            const menu_popup_el = E("div", {
                class: "menu-popup",
                id: `menu-popup-${uid()}`,
                tabIndex: "-1",
                role: "menu",
            });
            menu_popup_el.style.touchAction = "pan-y"; // will allow for scrolling overflowing menus in the future, but prevent event delay and double tap to zoom
            menu_popup_el.style.outline = "none";
            const menu_popup_table_el = E("table", { class: "menu-popup-table" });
            menu_popup_el.appendChild(menu_popup_table_el);
    
            this.element = menu_popup_el;
            menu_popup_by_el.set(menu_popup_el, this);
    
            let submenus = [];
    
            menu_popup_el.addEventListener("keydown", handleKeyDown);
    
            menu_popup_el.addEventListener("pointerleave", () => {
                // if there's a submenu popup, highlight the item for that, otherwise nothing
    
                // could use aria-expanded for selecting this, alternatively
                for (const submenu of submenus) {
                    if (submenu.submenu_popup_el.style.display !== "none") {
                        this.highlight(submenu.item_el);
                        return;
                    }
                }
                this.highlight(-1);
            });
    
            menu_popup_el.addEventListener("focusin", (e) => {
                // prevent focus going to menu items; as designed, it works with aria-activedescendant and focus on the menu popup itself
                // (on desktop when clicking (and dragging out) then pressing a key, or on mobile when tapping, a focus ring was visible, and it wouldn't go away with keyboard navigation either)
                menu_popup_el.focus({ preventScroll: true });
            });
    
            let last_item_el;
            this.highlight = (index_or_element) => { // index includes separators
                let item_el = index_or_element;
                if (typeof index_or_element === "number") {
                    item_el = this.itemElements[index_or_element];
                }
                if (last_item_el && last_item_el !== item_el) {
                    last_item_el.classList.remove("highlight");
                }
                if (item_el) {
                    item_el.classList.add("highlight");
                    menu_popup_el.setAttribute("aria-activedescendant", item_el.id);
                    last_item_el = item_el;
                } else {
                    menu_popup_el.removeAttribute("aria-activedescendant");
                    last_item_el = null;
                }
            };
    
            if (menu_items.length === 0) {
                menu_items = [{
                    label: "(Empty)",
                    enabled: false,
                }];
            }
    
            menu_items.forEach((item, item_index) => {
                const row_el = E("tr", { class: "menu-row" });
                this.itemElements.push(row_el);
                menu_popup_table_el.appendChild(row_el);
                if (item === MENU_DIVIDER) {
                    const td_el = E("td", { colspan: 4 });
                    const hr_el = E("hr", { class: "menu-hr" });
                    // hr_el.setAttribute("role", "separator"); // this is the implicit ARIA role for <hr>
                    // and setting it on the <tr> might cause problems due to multiple elements with the role
                    // hopefully it's fine that the semantic <hr> is nested?
                    td_el.appendChild(hr_el);
                    row_el.appendChild(td_el);
                    // Favorites menu behavior:
                    // hr_el.addEventListener("click", () => {
                    // 	this.highlight(-1);
                    // });
                    // Normal menu behavior:
                    hr_el.addEventListener("pointerenter", () => {
                        this.highlight(-1);
                    });
                } else {
                    const item_el = row_el;
                    item_el.classList.add("menu-item");
                    item_el.id = `menu-item-${uid()}`;
                    item_el.tabIndex = -1; // may be needed for aria-activedescendant in some browsers?
                    item_el.setAttribute("role", item.checkbox ? "menuitemcheckbox" : "menuitem");
                    // prevent announcing the SHORTCUT (distinct from the hotkey, which would already not be announced unless it's e.g. a translated string like "새로 만들기 (&N)")
                    // remove_hotkey so it doesn't announce an ampersand
                    item_el.setAttribute("aria-label", remove_hotkey(item.label || item.item));
                    // include the shortcut semantically; if you want to display the shortcut differently than aria-keyshortcuts syntax,
                    // provide both ariaKeyShortcuts and shortcutLabel (old API: shortcut)
                    item_el.setAttribute("aria-keyshortcuts", item.ariaKeyShortcuts || item.shortcut || item.shortcutLabel);
    
                    if (item.description) {
                        item_el.setAttribute("aria-description", item.description);
                    }
                    const checkbox_area_el = E("td", { class: "menu-item-checkbox-area" });
                    const label_el = E("td", { class: "menu-item-label" });
                    const shortcut_el = E("td", { class: "menu-item-shortcut" });
                    const submenu_area_el = E("td", { class: "menu-item-submenu-area" });
    
                    item_el.appendChild(checkbox_area_el);
                    item_el.appendChild(label_el);
                    item_el.appendChild(shortcut_el);
                    item_el.appendChild(submenu_area_el);
    
                    label_el.innerHTML = display_hotkey(item.label || item.item);
                    shortcut_el.textContent = item.shortcut;
    
                    menu_popup_el.addEventListener("update", () => {
                        // item_el.disabled = is_disabled(item); // doesn't work, probably because it's a <tr>
                        if (is_disabled(item)) {
                            item_el.setAttribute("disabled", "");
                            item_el.setAttribute("aria-disabled", "true");
                        } else {
                            item_el.removeAttribute("disabled");
                            item_el.removeAttribute("aria-disabled");
                        }
                        if (item.checkbox && item.checkbox.check) {
                            const checked = item.checkbox.check();
                            // @TODO: use CSS for checkmark icon so it can be styled per theme
                            // checkbox_area_el.classList.toggle("checked", checked);
                            // use visibility rather than display so it doesn't affect item height
                            checkbox_area_el.querySelector("svg").style.visibility = checked ? "visible" : "hidden";
                            item_el.setAttribute("aria-checked", checked ? "true" : "false");
                        }
                    });
                    // You may ask, why not call `send_info_event` in `highlight`?
                    // Consider the case where you hover to open a menu, and it sets highlight to none,
                    // it shouldn't reset the status bar. It needs to be more based on the pointer and keyboard interactions directly.
                    // *Maybe* it could be a parameter (to `highlight`) if that's really helpful, but it's probably not.
                    // *Maybe* it could look at more of the overall state within `highlight`,
                    // but could it distinguish hovering an outer vs an inner item if two are highlighted?
                    item_el.addEventListener("pointerenter", () => {
                        menu_popup_el.dispatchEvent(new CustomEvent("update"), {}); // @TODO: why?
                        this.highlight(item_index);
                        send_info_event(item);
                    });
                    item_el.addEventListener("pointerleave", (event) => {
                        if (
                            menu_popup_el.style.display !== "none" && // not "left" due to closing
                            event.pointerType !== "touch" // not "left" as in finger lifting off
                        ) {
                            send_info_event();
                        }
                    });
    
                    if (item.checkbox) {
                        checkbox_area_el.innerHTML = `
                            <svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"
                                style="fill:currentColor;display:inline-block;vertical-align:middle"
                            >
                                <path d="M5 7v3l2 2 5-5V4L7 9Z"/>
                            </svg>
                        `;
                    }
                    // @TODO: radio menu item support
                    // if (item.radio) {
                    // 	checkbox_area_el.innerHTML = `
                    // 		<svg width="16" height="16" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"
                    // 			style="fill:currentColor;display:inline-block;vertical-align:middle"
                    // 		>
                    // 			<circle cx="8" cy="8" r="3"/>
                    // 		</svg>
                    // 	`;
                    // }
    
                    let open_submenu, submenu_popup_el;
                    if (item.submenu) {
                        item_el.classList.add("has-submenu");
                        submenu_area_el.innerHTML = `
                            <svg width="16" height="16" xmlns="http://www.w3.org/2000/svg"
                                style="fill:currentColor;display:inline-block;vertical-align:middle"
                            >
                                <path d="m6 4 4 4-4 4z"/>
                            </svg>
                        `;
                        menu_popup_el.addEventListener("update", () => {
                            submenu_area_el.querySelector("svg").style.transform = get_direction() === "rtl" ? "scaleX(-1)" : "";
                        });
    
                        const submenu_popup = new MenuPopup(item.submenu, { parentMenuPopup: this });
                        submenu_popup_el = submenu_popup.element;
                        document.body?.appendChild(submenu_popup_el);
                        submenu_popup_el.style.display = "none";
    
                        item_el.setAttribute("aria-haspopup", "true");
                        item_el.setAttribute("aria-expanded", "false");
                        item_el.setAttribute("aria-controls", submenu_popup_el.id);
    
                        submenu_popups_by_menu_item_el.set(item_el, submenu_popup);
                        parent_item_el_by_popup_el.set(submenu_popup_el, item_el);
                        submenu_popup_el.dataset.semanticParent = menu_popup_el.id; // for $Window to understand the popup belongs to its window
                        menu_popup_el.setAttribute("aria-owns", `${menu_popup_el.getAttribute("aria-owns") || ""} ${submenu_popup_el.id}`);
                        submenu_popup_el.setAttribute("aria-labelledby", item_el.id);
    
    
                        open_submenu = (highlight_first = true) => {
                            if (submenu_popup_el.style.display !== "none") {
                                return;
                            }
                            close_submenus_at_this_level();
    
                            item_el.setAttribute("aria-expanded", "true");
    
                            submenu_popup_el.style.display = "";
                            submenu_popup_el.style.zIndex = get_new_menu_z_index();
                            submenu_popup_el.setAttribute("dir", get_direction());
                            if (!submenu_popup_el.parentElement) {
                                document.body.appendChild(submenu_popup_el);
                            }
    
                            // console.log("open_submenu — submenu_popup_el.style.zIndex", submenu_popup_el.style.zIndex, "$Window.Z_INDEX", $Window.Z_INDEX, "menus_el.closest('.window').style.zIndex", menus_el.closest(".window").style.zIndex);
                            // setTimeout(() => { console.log("after timeout, menus_el.closest('.window').style.zIndex", menus_el.closest(".window").style.zIndex); }, 0);
                            submenu_popup_el.dispatchEvent(new CustomEvent("update"), {});
                            if (highlight_first) {
                                submenu_popup.highlight(0);
                                send_info_event(submenu_popup.menuItems[0]);
                            } else {
                                submenu_popup.highlight(-1);
                                // send_info_event(); // no, keep the status bar text!
                            }
    
                            const rect = item_el.getBoundingClientRect();
                            let submenu_popup_rect = submenu_popup_el.getBoundingClientRect();
                            submenu_popup_el.style.position = "absolute";
                            submenu_popup_el.style.left = `${(get_direction() === "rtl" ? rect.left - submenu_popup_rect.width : rect.right) + window.scrollX}px`;
                            submenu_popup_el.style.top = `${rect.top + window.scrollY}px`;
    
                            submenu_popup_rect = submenu_popup_el.getBoundingClientRect();
                            // This is surely not the cleanest way of doing this,
                            // and the logic is not very robust in the first place,
                            // but I want to get RTL support done and so I'm mirroring this in the simplest way possible.
                            if (get_direction() === "rtl") {
                                if (submenu_popup_rect.left < 0) {
                                    submenu_popup_el.style.left = `${rect.right}px`;
                                    submenu_popup_rect = submenu_popup_el.getBoundingClientRect();
                                    if (submenu_popup_rect.right > innerWidth) {
                                        submenu_popup_el.style.left = `${innerWidth - submenu_popup_rect.width}px`;
                                    }
                                }
                            } else {
                                if (submenu_popup_rect.right > innerWidth) {
                                    submenu_popup_el.style.left = `${rect.left - submenu_popup_rect.width}px`;
                                    submenu_popup_rect = submenu_popup_el.getBoundingClientRect();
                                    if (submenu_popup_rect.left < 0) {
                                        submenu_popup_el.style.left = "0";
                                    }
                                }
                            }
    
                            submenu_popup_el.focus({ preventScroll: true });
                            active_menu_popup = submenu_popup;
                        };
    
                        function close_submenu() {
                            // idempotent
                            submenu_popup_el.style.display = "none";
                            submenu_popup.highlight(-1);
                            item_el.setAttribute("aria-expanded", "false");
                            if (submenu_popup_el._submenus) {
                                for (const submenu of submenu_popup_el._submenus) {
                                    submenu.close_submenu();
                                }
                            }
                        }
    
                        submenus.push({
                            item_el,
                            submenu_popup_el,
                            open_submenu,
                            close_submenu,
                        });
                        menu_popup_el._submenus = submenus;
    
                        function close_submenus_at_this_level() {
                            for (const submenu of submenus) {
                                submenu.close_submenu();
                            }
                            menu_popup_el.focus({ preventScroll: true });
                        }
    
                        // It should close when hovering a different higher level menu
                        // after a delay, unless the mouse returns to the submenu.
                        // If you return the mouse from a submenu into its parent
                        // *directly onto the parent menu item*, it stays open, but if you cross other menu items
                        // in the parent menu, (@TODO:) it'll close after the delay even if you land on the parent menu item.
                        // @TODO: Highlight the submenu-containing item while the submenu is open,
                        // unless hovering a different item at that level (one highlight per level max).
                        // @TODO: once a submenu opens (completing its animation if it has one),
                        // - up/down should navigate the submenu (although it should not show as focused right away)
                        //   - the rule is probably: up/down navigate the bottom-most submenu always (as long as it's not animating)
                        // - the submenu cancels its closing timeout (if you've moved outside all menus, say)
                        // @TODO: make this more robust in general! Make some automated tests.
    
                        let open_tid, close_tid;
                        submenu_popup_el.addEventListener("pointerenter", () => {
                            if (open_tid) { clearTimeout(open_tid); open_tid = null; }
                            if (close_tid) { clearTimeout(close_tid); close_tid = null; }
                        });
                        item_el.addEventListener("pointerenter", () => {
                            // @TODO: don't cancel close timer? in Windows 98 it'll still close after a delay if you hover the submenu's parent item
                            if (open_tid) { clearTimeout(open_tid); open_tid = null; }
                            if (close_tid) { clearTimeout(close_tid); close_tid = null; }
                            open_tid = setTimeout(() => {
                                open_submenu(false);
                            }, 501); // @HACK: slightly longer than close timer so it doesn't close immediately
                        });
                        item_el.addEventListener("pointerleave", () => {
                            if (open_tid) { clearTimeout(open_tid); open_tid = null; }
                        });
                        menu_popup_el.addEventListener("pointerenter", (event) => {
                            // console.log(event.target.closest(".menu-item"));
                            if (event.target.closest(".menu-item") === item_el) {
                                return;
                            }
                            if (!close_tid) {
                                // This is a little confusing, with timers per-item...
                                // @TODO: try doing this with just one or two timers.
                                // if (submenus.some(submenu => submenu.submenu_popup_el.style.display !== "none")) {
                                if (submenu_popup_el.style.display !== "none") {
                                    close_tid = setTimeout(() => {
                                        if (!window.debugKeepMenusOpen) {
                                            // close_submenu();
                                            close_submenus_at_this_level();
                                        }
                                    }, 500);
                                }
                            }
                        });
                        // keep submenu open while mouse is outside any parent menus
                        menu_popup_el.addEventListener("pointerleave", () => {
                            if (close_tid) { clearTimeout(close_tid); close_tid = null; }
                        });
    
                        item_el.addEventListener("pointerdown", () => { open_submenu(false); });
                    }
    
                    let just_activated = false; // to prevent double-activation from pointerup + click
                    const item_action = () => {
                        if (just_activated) {
                            return;
                        }
                        just_activated = true;
                        setTimeout(() => { just_activated = false; }, 10);
    
                        if (item.checkbox) {
                            if (item.checkbox.toggle) {
                                item.checkbox.toggle();
                            }
                            menu_popup_el.dispatchEvent(new CustomEvent("update"), {});
                        } else if (item.action) {
                            close_menus();
                            refocus_window(); // before action, so things like copy/paste have a better chance of working
                            item.action();
                        }
                    };
                    // pointerup is for gliding to menu items to activate
                    item_el.addEventListener("pointerup", e => {
                        if (e.pointerType === "mouse" && e.button !== 0) {
                            return;
                        }
                        if (e.pointerType === "touch") {
                            // Will use click instead; otherwise focus is lost on a delay: if it opens a dialog for example,
                            // you have to hold down on the menu item for a bit otherwise it'll blur the dialog after opening.
                            // I think this is caused by the pointer falling through to elements without touch-action defined.
                            // RIGHT NOW, gliding to menu items isn't supported for touch anyways,
                            // although I'd like to support it in the future.
                            // Well, it might have accessibility problems, so maybe not. I think this is fine.
                            return;
                        }
                        item_el.click();
                    });
                    item_el.addEventListener("click", e => {
                        if (item.submenu) {
                            open_submenu(true);
                        } else {
                            item_action();
                        }
                    });
                }
            });
        }
    
        // let this_click_opened_the_menu = false;
        const make_menu_button = (menus_key, menu_items) => {
            const menu_button_el = E("div", {
                class: "menu-button",
                "aria-expanded": "false",
                "aria-haspopup": "true",
                role: "menuitem",
            });
    
            menus_el.appendChild(menu_button_el);
    
            const menu_popup = new MenuPopup(menu_items);
            const menu_popup_el = menu_popup.element;
            document.body?.appendChild(menu_popup_el);
            submenu_popups_by_menu_item_el.set(menu_button_el, menu_popup);
            parent_item_el_by_popup_el.set(menu_popup_el, menu_button_el);
            menu_button_el.id = `menu-button-${menus_key}-${uid()}`;
            menu_popup_el.dataset.semanticParent = menu_button_el.id; // for $Window to understand the popup belongs to its window
            menu_button_el.setAttribute("aria-controls", menu_popup_el.id);
            menu_popup_el.setAttribute("aria-labelledby", menu_button_el.id);
            menus_el.setAttribute("aria-owns", `${menus_el.getAttribute("aria-owns") || ""} ${menu_popup_el.id}`);
    
            const update_position_from_containing_bounds = () => {
                const rect = menu_button_el.getBoundingClientRect();
                let popup_rect = menu_popup_el.getBoundingClientRect();
                menu_popup_el.style.position = "absolute";
                menu_popup_el.style.left = `${(get_direction() === "rtl" ? rect.right - popup_rect.width : rect.left) + window.scrollX}px`;
                menu_popup_el.style.top = `${rect.bottom + window.scrollY}px`;
    
                const uncorrected_rect = menu_popup_el.getBoundingClientRect();
                // rounding down is needed for RTL layout for the rightmost menu, to prevent a scrollbar
                if (Math.floor(uncorrected_rect.right) > innerWidth) {
                    menu_popup_el.style.left = `${innerWidth - uncorrected_rect.width}px`;
                }
                if (Math.ceil(uncorrected_rect.left) < 0) {
                    menu_popup_el.style.left = "0px";
                }
            };
            window.addEventListener("resize", update_position_from_containing_bounds);
            menu_popup_el.addEventListener("update", update_position_from_containing_bounds);
            // update_position_from_containing_bounds(); // will be called when the menu is opened
    
            const menu_id = menus_key.replace("&", "").replace(/ /g, "-").toLowerCase();
            menu_button_el.classList.add(`${menu_id}-menu-button`);
            // menu_popup_el.id = `${menu_id}-menu-popup-${uid()}`; // id is created by MenuPopup and changing it breaks the data-semantic-parent relationship
            menu_popup_el.style.display = "none";
            menu_button_el.innerHTML = display_hotkey(menus_key);
            menu_button_el.tabIndex = -1;
    
            menu_button_el.setAttribute("aria-haspopup", "true");
            menu_button_el.setAttribute("aria-controls", menu_popup_el.id);
    
            menu_button_el.addEventListener("focus", () => {
                top_level_highlight(menus_key);
            });
            menu_button_el.addEventListener("pointerdown", e => {
                if (menu_button_el.classList.contains("active")) {
                    menu_button_el.dispatchEvent(new CustomEvent("release", {}));
                    refocus_window();
                    e.preventDefault(); // needed for refocus_window() to work
                } else {
                    open_top_level_menu(e.type);
                }
            });
            menu_button_el.addEventListener("pointerenter", e => {
                top_level_highlight(menus_key);
                if (e.pointerType === "touch") {
                    return;
                }
                if (selecting_menus) {
                    open_top_level_menu(e.type);
                }
            });
            function open_top_level_menu(type = "other") {
                close_menus();
    
                menu_button_el.classList.add("active");
                menu_button_el.setAttribute("aria-expanded", "true");
                menu_popup_el.style.display = "";
                menu_popup_el.style.zIndex = get_new_menu_z_index();
                menu_popup_el.setAttribute("dir", get_direction());
                if (!menu_popup_el.parentElement) {
                    document.body.appendChild(menu_popup_el);
                }
                // console.log("pointerdown (possibly simulated) — menu_popup_el.style.zIndex", menu_popup_el.style.zIndex, "$Window.Z_INDEX", $Window.Z_INDEX, "menus_el.closest('.window').style.zIndex", menus_el.closest(".window").style.zIndex);
                // setTimeout(() => { console.log("after timeout, menus_el.closest('.window').style.zIndex", menus_el.closest(".window").style.zIndex); }, 0);
                top_level_highlight(menus_key);
    
                menu_popup_el.dispatchEvent(new CustomEvent("update"), {});
    
                selecting_menus = true;
    
                menu_popup_el.focus({ preventScroll: true });
                active_menu_popup = menu_popup;
    
                if (type === "keydown") {
                    menu_popup.highlight(0);
                    send_info_event(menu_popup.menuItems[0]);
                } else {
                    send_info_event(); // @TODO: allow descriptions on top level menus
                }
            };
            menu_button_el.addEventListener("release", () => {
                selecting_menus = false;
    
                menu_button_el.classList.remove("active");
                if (!window.debugKeepMenusOpen) {
                    menu_popup_el.style.display = "none";
                    menu_popup.highlight(-1);
                    menu_button_el.setAttribute("aria-expanded", "false");
                }
    
                menus_el.dispatchEvent(new CustomEvent("default-info", {}));
            });
            top_level_menus.push({
                menu_button_el,
                menu_popup_el,
                menus_key,
                hotkey: get_hotkey(menus_key),
                open_top_level_menu,
            });
        };
        for (const menu_key in menus) {
            make_menu_button(menu_key, menus[menu_key]);
        }
    
        window.addEventListener("keydown", e => {
            // close any errant menus
            // taking care not to interfere with regular Escape key behavior
            // @TODO: listen for menus_el removed from DOM, and close menus there
            if (
                !document.activeElement ||
                !document.activeElement.closest || // window or document
                !document.activeElement.closest(".menus, .menu-popup")
            ) {
                if (e.keyCode === 27) { // Escape
                    if (any_open_menus()) {
                        close_menus();
                        e.preventDefault();
                    }
                }
            }
        });
        // window.addEventListener("blur", close_menus);
        window.addEventListener("blur", (event) => {
            // hack for Pinball (in 98.js.org) where it triggers fake blur events
            // in order to pause the game
            if (!event.isTrusted) {
                return;
            }
            close_menus();
        });
        function close_menus_on_click_outside(event) {
            if (event.target?.closest?.(".menus, .menu-popup")) {
                return;
            }
            // window.console && console.log(event.type, "occurred outside of menus (on ", event.target, ") so...");
            close_menus();
        }
        window.addEventListener("pointerdown", close_menus_on_click_outside);
        window.addEventListener("pointerup", close_menus_on_click_outside);
    
        let keyboard_scope_elements = [];
        function set_keyboard_scope(...elements) {
            for (const el of keyboard_scope_elements) {
                el.removeEventListener("keydown", keyboard_scope_keydown);
            }
            keyboard_scope_elements = elements;
            for (const el of keyboard_scope_elements) {
                el.addEventListener("keydown", keyboard_scope_keydown);
            }
        }
        function keyboard_scope_keydown(e) {
            // Close menus if the user presses almost any key combination
            // e.g. if you look in the menu to remember a shortcut,
            // and then use the shortcut.
            if (
                (e.ctrlKey || e.metaKey) && // Ctrl or Command held down
                // and anything then pressed other than Ctrl or Command
                e.keyCode !== 17 &&
                e.keyCode !== 91 &&
                e.keyCode !== 93 &&
                e.keyCode !== 224
            ) {
                close_menus();
                return;
            }
            if (e.defaultPrevented) {
                return; // closing menus above is meant to be done when activating unrelated shortcuts
                // but stuff after this is should not be handled at the same time as something else
            }
            if (e.altKey && !e.shiftKey && !e.ctrlKey && !e.metaKey) { // Alt held
                const menu = top_level_menus.find((menu) =>
                    menu.hotkey.toLowerCase() === String.fromCharCode(e.keyCode).toLowerCase()
                );
                if (menu) {
                    e.preventDefault();
                    menu.open_top_level_menu("keydown");
                }
            }
        }
    
        set_keyboard_scope(window);
    
        this.element = menus_el;
        this.closeMenus = close_menus;
        this.setKeyboardScope = set_keyboard_scope;
    }
    
    exports.MenuBar = MenuBar;
    exports.MENU_DIVIDER = MENU_DIVIDER;
    
    })(window);    </script>
<script>((exports) => {

    // TODO: E\("([a-z]+)"\) -> "<$1>" or get rid of jQuery as a dependency
    function E(tagName) {
        return document.createElement(tagName);
    }
    
    function element_to_string(element) {
        // returns a CSS-selector-like string for the given element
        // if (element instanceof Element) { // doesn't work with different window.Element from iframes
        if (typeof element === "object" && "tagName" in element) {
            return element.tagName.toLowerCase() +
                (element.id ? "#" + element.id : "") +
                (element.className ? "." + element.className.split(" ").join(".") : "") +
                (element.src ? `[src="${element.src}"]` : "") + // Note: not escaped; may not actually work as a selector (but this is for debugging)
                (element.srcdoc ? "[srcdoc]" : "") + // (srcdoc can be long)
                (element.href ? `[href="${element.href}"]` : "");
        } else if (element) {
            return element.constructor.name;
        } else {
            return `${element}`;
        }
    }
    
    function find_tabstops(container_el) {
        const $el = $(container_el);
        // This function finds focusable controls, but not necessarily all of them;
        // for radio elements, it only gives one: either the checked one, or the first one if none are checked.
    
        // Note: for audio[controls], Chrome at least has two tabstops (the audio element and three dots menu button).
        // It might be possible to detect this in the shadow DOM, I don't know, I haven't worked with the shadow DOM.
        // But it might be more reliable to make a dummy tabstop element to detect when you tab out of the first/last element.
        // Also for iframes!
        // Assuming that doesn't mess with screen readers.
        // Right now you can't tab to the three dots menu if it's the last element.
        // @TODO: see what ally.js does. Does it handle audio[controls]? https://allyjs.io/api/query/tabsequence.html
    
        let $controls = $el.find(`
            input:enabled,
            textarea:enabled,
            select:enabled,
            button:enabled,
            a[href],
            [tabIndex='0'],
            details summary,
            iframe,
            object,
            embed,
            video[controls],
            audio[controls],
            [contenteditable]:not([contenteditable='false'])
        `).filter(":visible");
        // const $controls = $el.find(":tabbable"); // https://api.jqueryui.com/tabbable-selector/
    
        // Radio buttons should be treated as a group with one tabstop.
        // If there's no selected ("checked") radio, it should still visit the group,
        // but if there is a selected radio in the group, it should skip all unselected radios in the group.
        const radios = {}; // best radio found so far, per group
        const to_skip = [];
        for (const el of $controls.toArray()) {
            if (el.nodeName.toLowerCase() === "input" && el.type === "radio") {
                if (radios[el.name]) {
                    if (el.checked) {
                        to_skip.push(radios[el.name]);
                        radios[el.name] = el;
                    } else {
                        to_skip.push(el);
                    }
                } else {
                    radios[el.name] = el;
                }
            }
        }
        const $tabstops = $controls.not(to_skip);
        // debug viz:
        // $tabstops.css({boxShadow: "0 0 2px 2px green"});
        // $(to_skip).css({boxShadow: "0 0 2px 2px gray"})
        return $tabstops;
    }
    var $G = $(window);
    
    
    $Window.Z_INDEX = 5;
    
    var minimize_slots = []; // for if there's no taskbar
    
    // @TODO: make this a class,
    // instead of a weird pseudo-class
    function $Window(options) {
        options = options || {};
        // @TODO: handle all option defaults here
        // and validate options.
    
        var $w = $(E("div")).addClass("window os-window").appendTo("body");
        $w[0].$window = $w;
        $w.element = $w[0];
        $w[0].id = `os-window-${Math.random().toString(36).substr(2, 9)}`;
        $w.$titlebar = $(E("div")).addClass("window-titlebar").appendTo($w);
        $w.$title_area = $(E("div")).addClass("window-title-area").appendTo($w.$titlebar);
        $w.$title = $(E("span")).addClass("window-title").appendTo($w.$title_area);
        if (options.toolWindow) {
            options.minimizeButton = false;
            options.maximizeButton = false;
        }
        if (options.minimizeButton !== false) {
            $w.$minimize = $(E("button")).addClass("window-minimize-button window-action-minimize window-button").appendTo($w.$titlebar);
            $w.$minimize.attr("aria-label", "Minimize window"); // @TODO: for taskbarless minimized windows, "restore"
            $w.$minimize.append("<span class='window-button-icon'></span>");
        }
        if (options.maximizeButton !== false) {
            $w.$maximize = $(E("button")).addClass("window-maximize-button window-action-maximize window-button").appendTo($w.$titlebar);
            $w.$maximize.attr("aria-label", "Maximize or restore window"); // @TODO: specific text for the state
            if (!options.resizable) {
                $w.$maximize.attr("disabled", true);
            }
            $w.$maximize.append("<span class='window-button-icon'></span>");
        }
        if (options.closeButton !== false) {
            $w.$x = $(E("button")).addClass("window-close-button window-action-close window-button").appendTo($w.$titlebar);
            $w.$x.attr("aria-label", "Close window");
            $w.$x.append("<span class='window-button-icon'></span>");
        }
        $w.$content = $(E("div")).addClass("window-content").appendTo($w);
        $w.$content.attr("tabIndex", "-1");
        $w.$content.css("outline", "none");
        if (options.toolWindow) {
            $w.addClass("tool-window");
        }
        if (options.parentWindow) {
            options.parentWindow.addChildWindow($w);
            // semantic parent logic is currently only suited for tool windows
            // for dialog windows, it would make the dialog window not show as focused
            // (alternatively, I could simply, when following the semantic parent chain, look for windows that are not tool windows)
            if (options.toolWindow) {
                $w[0].dataset.semanticParent = options.parentWindow[0].id;
            }
        }
    
        var $component = options.$component;
        if (typeof options.icon === "object" && "tagName" in options.icon) {
            options.icons = { any: options.icon };
        } else if (options.icon) {
            // old terrible API using globals that you have to define
            console.warn("DEPRECATED: use options.icons instead of options.icon, e.g. new $Window({icons: {16: 'app-16x16.png', any: 'app-icon.svg'}})");
            if (typeof $Icon !== "undefined" && typeof TITLEBAR_ICON_SIZE !== "undefined") {
                $w.icon_name = options.icon;
                $w.$icon = $Icon(options.icon, TITLEBAR_ICON_SIZE).prependTo($w.$titlebar);
            } else {
                throw new Error("Use {icon: img_element} or {icons: {16: url_or_img_element}} options");
            }
        }
        $w.icons = options.icons || {};
        let iconSize = 16;
        $w.setTitlebarIconSize = function (target_icon_size) {
            if ($w.icons) {
                $w.$icon?.remove();
                $w.$icon = $($w.getIconAtSize(target_icon_size));
                $w.$icon.prependTo($w.$titlebar);
            }
            iconSize = target_icon_size;
            $w.trigger("icon-change");
        };
        $w.getTitlebarIconSize = function () {
            return iconSize;
        };
        // @TODO: this could be a static method, like OSGUI.getIconAtSize(icons, targetSize)
        $w.getIconAtSize = function (target_icon_size) {
            let icon_size;
            if ($w.icons[target_icon_size]) {
                icon_size = target_icon_size;
            } else if ($w.icons["any"]) {
                icon_size = "any";
            } else {
                const sizes = Object.keys($w.icons).filter(size => isFinite(size) && isFinite(parseFloat(size)));
                sizes.sort((a, b) => Math.abs(a - target_icon_size) - Math.abs(b - target_icon_size));
                icon_size = sizes[0];
            }
            if (icon_size) {
                const icon = $w.icons[icon_size];
                let icon_element;
                if (icon.nodeType !== undefined) {
                    icon_element = icon.cloneNode(true);
                } else {
                    icon_element = E("img");
                    const $icon = $(icon_element);
                    if (icon.srcset) {
                        $icon.attr("srcset", icon.srcset);
                    } else {
                        $icon.attr("src", icon.src || icon);
                    }
                    $icon.attr({
                        width: icon_size,
                        height: icon_size,
                        draggable: false,
                    });
                    $icon.css({
                        width: target_icon_size,
                        height: target_icon_size,
                    });
                }
                return icon_element;
            }
            return null;
        };
        // @TODO: automatically update icon size based on theme (with a CSS variable)
        $w.setTitlebarIconSize(iconSize);
    
        $w.getIconName = () => {
            console.warn("DEPRECATED: use $w.icons object instead of $w.icon_name");
            return $w.icon_name;
        };
        $w.setIconByID = (icon_name) => {
            console.warn("DEPRECATED: use $w.setIcons(icons) instead of $w.setIconByID(icon_name)");
            var old_$icon = $w.$icon;
            $w.$icon = $Icon(icon_name, TITLEBAR_ICON_SIZE);
            old_$icon.replaceWith($w.$icon);
            $w.icon_name = icon_name;
            $w.task?.updateIcon();
            $w.trigger("icon-change");
            return $w;
        };
        $w.setIcons = (icons) => {
            $w.icons = icons;
            $w.setTitlebarIconSize(iconSize);
            $w.task?.updateIcon();
            // icon-change already sent by setTitlebarIconSize
        };
    
        if ($component) {
            $w.addClass("component-window");
        }
    
        setTimeout(() => {
            if (get_direction() == "rtl") {
                $w.addClass("rtl"); // for reversing the titlebar gradient
            }
        }, 0);
    
        // returns writing/layout direction, "ltr" or "rtl"
        function get_direction() {
            return window.get_direction ? window.get_direction() : getComputedStyle($w[0]).direction;
        }
    
        // This is very silly, using jQuery's event handling to implement simpler event handling.
        // But I'll implement it in a non-silly way at least when I remove jQuery. Maybe sooner.
        const $event_target = $({});
        const make_simple_listenable = (name) => {
            return (callback) => {
                const fn = () => {
                    callback();
                };
                $event_target.on(name, fn);
                const dispose = () => {
                    $event_target.off(name, fn);
                };
                return dispose;
            };
        };
        $w.onFocus = make_simple_listenable("focus");
        $w.onBlur = make_simple_listenable("blur");
        $w.onClosed = make_simple_listenable("closed");
    
        $w.setDimensions = ({ innerWidth, innerHeight, outerWidth, outerHeight }) => {
            let width_from_frame, height_from_frame;
            // It's good practice to make all measurements first, then update the DOM.
            // Once you update the DOM, the browser has to recalculate layout, which can be slow.
            if (innerWidth) {
                width_from_frame = $w.outerWidth() - $w.$content.outerWidth();
            }
            if (innerHeight) {
                height_from_frame = $w.outerHeight() - $w.$content.outerHeight();
                const $menu_bar = $w.$content.find(".menus"); // only if inside .content; might move to a slot outside .content later
                if ($menu_bar.length) {
                    // maybe this isn't technically part of the frame, per se? but it's part of the non-client area, which is what I technically mean.
                    height_from_frame += $menu_bar.outerHeight();
                }
            }
            if (outerWidth) {
                $w.outerWidth(outerWidth);
            }
            if (outerHeight) {
                $w.outerHeight(outerHeight);
            }
            if (innerWidth) {
                $w.outerWidth(innerWidth + width_from_frame);
            }
            if (innerHeight) {
                $w.outerHeight(innerHeight + height_from_frame);
            }
        };
        $w.setDimensions(options);
    
        let child_$windows = [];
        $w.addChildWindow = ($child_window) => {
            child_$windows.push($child_window);
        };
        const showAsFocused = () => {
            if ($w.hasClass("focused")) {
                return;
            }
            $w.addClass("focused");
            $event_target.triggerHandler("focus");
        };
        const stopShowingAsFocused = () => {
            if (!$w.hasClass("focused")) {
                return;
            }
            $w.removeClass("focused");
            $event_target.triggerHandler("blur");
        };
        $w.focus = () => {
            // showAsFocused();	
            $w.bringToFront();
            refocus();
        };
        $w.blur = () => {
            stopShowingAsFocused();
            if (document.activeElement && document.activeElement.closest(".window") == $w[0]) {
                document.activeElement.blur();
            }
        };
    
        if (options.toolWindow) {
            if (options.parentWindow) {
                options.parentWindow.onFocus(showAsFocused);
                options.parentWindow.onBlur(stopShowingAsFocused);
                // TODO: also show as focused if focus is within the window
    
                // initial state
                // might need a setTimeout, idk...
                if (document.activeElement && document.activeElement.closest(".window") == options.parentWindow[0]) {
                    showAsFocused();
                }
            } else {
                // the browser window is the parent window
                // show focus whenever the browser window is focused
                $(window).on("focus", showAsFocused);
                $(window).on("blur", stopShowingAsFocused);
                // initial state
                if (document.hasFocus()) {
                    showAsFocused();
                }
            }
        } else {
            // global focusout is needed, to continue showing as focused while child windows or menu popups are focused (@TODO: Is this redundant with focusin?)
            // global focusin is needed, to show as focused when a child window becomes focused (when perhaps nothing was focused before, so no focusout event)
            // global blur is needed, to show as focused when an iframe gets focus, because focusin/out doesn't fire at all in that case
            // global focus is needed, to stop showing as focused when an iframe loses focus
            // pretty ridiculous!!
            // but it still doesn't handle the case where the browser window is not focused, and the user clicks an iframe directly.
            // for that, we need to listen inside the iframe, because no events are fired at all outside in that case,
            // and :focus/:focus-within doesn't work with iframes so we can't even do a hack with transitionstart.
            // @TODO: simplify the strategy; I ended up piling a few strategies on top of each other, and the earlier ones may be redundant.
            // In particular, 1. I ended up making it proactively inject into iframes, rather than when focused since there's a case where focus can't be detected otherwise.
            // 2. I ended up simulating focusin events for iframes.
            // I may want to rely on that, or, I may want to remove that and set up a refocus chain directly instead,
            // avoiding refocus() which may interfere with drag operations in an iframe when focusing the iframe (e.g. clicking into Paint to draw or drag a sub-window).
    
            // console.log("adding global focusin/focusout/blur/focus for window", $w[0].id);
            const global_focus_update_handler = make_focus_in_out_handler($w[0], true); // must be $w and not $content so semantic parent chain works, with [data-semantic-parent] pointing to the window not the content
            window.addEventListener("focusin", global_focus_update_handler);
            window.addEventListener("focusout", global_focus_update_handler);
            window.addEventListener("blur", global_focus_update_handler);
            window.addEventListener("focus", global_focus_update_handler);
    
            function setupIframe(iframe) {
                if (!focus_update_handlers_by_container.has(iframe)) {
                    const iframe_update_focus = make_focus_in_out_handler(iframe, false);
                    // this also operates as a flag to prevent multiple handlers from being added, or waiting for the iframe to load duplicately
                    focus_update_handlers_by_container.set(iframe, iframe_update_focus);
    
                    // @TODO: try removing setTimeout(s)
                    setTimeout(() => { // for iframe src to be set? I forget.
                        // Note: try must be INSIDE setTimeout, not outside, to work.
                        try {
                            const wait_for_iframe_load = (callback) => {
                                // Note: error may occur accessing iframe.contentDocument; this must be handled by the caller.
                                // To that end, this function must access it synchronously, to allow the caller to handle the error.
                                if (iframe.contentDocument.readyState == "complete") {
                                    callback();
                                } else {
                                    // iframe.contentDocument.addEventListener("readystatechange", () => {
                                    // 	if (iframe.contentDocument.readyState == "complete") {
                                    // 		callback();
                                    // 	}
                                    // });
                                    setTimeout(() => {
                                        wait_for_iframe_load(callback);
                                    }, 100);
                                }
                            };
                            wait_for_iframe_load(() => {
                                // console.log("adding focusin/focusout/blur/focus for iframe", iframe);
                                iframe.contentWindow.addEventListener("focusin", iframe_update_focus);
                                iframe.contentWindow.addEventListener("focusout", iframe_update_focus);
                                iframe.contentWindow.addEventListener("blur", iframe_update_focus);
                                iframe.contentWindow.addEventListener("focus", iframe_update_focus);
                                observeIframes(iframe.contentDocument);
                            });
                        } catch (error) {
                            warn_iframe_access(iframe, error);
                        }
                    }, 100);
                }
            }
    
            function observeIframes(container_node) {
                const observer = new MutationObserver((mutations) => {
                    for (const mutation of mutations) {
                        for (const node of mutation.addedNodes) {
                            if (node.tagName == "IFRAME") {
                                setupIframe(node);
                            }
                        }
                    }
                });
                observer.observe(container_node, { childList: true, subtree: true });
                // needed in recursive calls (for iframes inside iframes)
                // (for the window, it shouldn't be able to have iframes yet)
                for (const iframe of container_node.querySelectorAll("iframe")) {
                    setupIframe(iframe);
                }
            }
    
            observeIframes($w.$content[0]);
            
            function make_focus_in_out_handler(logical_container_el, is_root) {
                // In case of iframes, logical_container_el is the iframe, and container_node is the iframe's contentDocument.
                // container_node is not a parameter here because it can change over time, may be an empty document before the iframe is loaded.
    
                return function handle_focus_in_out(event) {
                    const container_node = logical_container_el.tagName == "IFRAME" ? logical_container_el.contentDocument : logical_container_el;
                    const document = container_node.ownerDocument ?? container_node;
                    // is this equivalent?
                    // const document = logical_container_el.tagName == "IFRAME" ? logical_container_el.contentDocument : logical_container_el.ownerDocument;
    
                    // console.log(`handling ${event.type} for container`, container_el);
                    let newly_focused = event ? (event.type === "focusout" || event.type === "blur") ? event.relatedTarget : event.target : document.activeElement;
                    if (event?.type === "blur") {
                        newly_focused = null; // only handle iframe
                    }
    
                    // console.log(`[${$w.title()}] (is_root=${is_root})`, `newly_focused is (preliminarily)`, element_to_string(newly_focused), `\nlogical_container_el`, logical_container_el, `\ncontainer_node`, container_node, `\ndocument.activeElement`, document.activeElement, `\ndocument.hasFocus()`, document.hasFocus(), `\ndocument`, document);
    
                    // Iframes are stingy about focus events, so we need to check if focus is actually within an iframe.
                    if (
                        document.activeElement &&
                        document.activeElement.tagName === "IFRAME" &&
                        (event?.type === "focusout" || event?.type === "blur") &&
                        !newly_focused // doesn't exist for security reasons in this case
                    ) {
                        newly_focused = document.activeElement;
                        // console.log(`[${$w.title()}] (is_root=${is_root})`, `newly_focused is (actually)`, element_to_string(newly_focused));
                    }
    
                    const outside_or_at_exactly =
                        !newly_focused ||
                        // contains() only works with DOM nodes (elements and documents), not window objects.
                        // Since container_node is a DOM node, it will never have a Window inside of it (ignoring iframes).
                        newly_focused.window === newly_focused || // is a Window object (cross-frame test)
                        !container_node.contains(newly_focused); // Note: node.contains(node) === true
                    const firmly_outside = outside_or_at_exactly && container_node !== newly_focused;
    
                    // console.log(`[${$w.title()}] (is_root=${is_root})`, `outside_or_at_exactly=${outside_or_at_exactly}`, `firmly_outside=${firmly_outside}`);
                    if (firmly_outside && is_root) {
                        stopShowingAsFocused();
                    }
                    if (
                        !outside_or_at_exactly &&
                        newly_focused.tagName !== "HTML" &&
                        newly_focused.tagName !== "BODY" &&
                        newly_focused !== container_node &&
                        !newly_focused.matches(".window-content") &&
                        !newly_focused.closest(".menus") &&
                        !newly_focused.closest(".window-titlebar")
                    ) {
                        last_focus_by_container.set(logical_container_el, newly_focused); // overwritten for iframes below
                        debug_focus_tracking(document, container_node, newly_focused, is_root);
                    }
    
                    if (
                        !outside_or_at_exactly &&
                        newly_focused.tagName === "IFRAME"
                    ) {
                        const iframe = newly_focused;
                        // console.log("iframe", iframe, onfocusin_by_container.has(iframe));
                        try {
                            const focus_in_iframe = iframe.contentDocument.activeElement;
                            if (
                                focus_in_iframe &&
                                focus_in_iframe.tagName !== "HTML" &&
                                focus_in_iframe.tagName !== "BODY" &&
                                !focus_in_iframe.closest(".menus")
                            ) {
                                // last_focus_by_container.set(logical_container_el, iframe); // done above
                                last_focus_by_container.set(iframe, focus_in_iframe);
                                debug_focus_tracking(iframe.contentDocument, iframe.contentDocument, focus_in_iframe, is_root);
                            }
                        } catch (e) {
                            warn_iframe_access(iframe, e);
                        }
                    }
    
    
                    // For child windows and menu popups, follow "semantic parent" chain.
                    // Menu popups and child windows aren't descendants of the window they belong to,
                    // but should keep the window shown as focused.
                    // (In principle this sort of feature could be useful for focus tracking*,
                    // but right now it's only for child windows and menu popups, which should not be tracked for refocus,
                    // so I'm doing this after last_focus_by_container.set, for now anyway.)
                    // ((*: and it may even be surprising if it doesn't work, if one sees the attribute on menus and attempts to use it.
                    // But who's going to see that? The menus close so it's a pain to see the DOM structure! :P **))
                    // (((**: without window.debugKeepMenusOpen)))
                    if (is_root) {
                        do {
                            // if (!newly_focused?.closest) {
                            // 	console.warn("what is this?", newly_focused);
                            // 	break;
                            // }
                            const waypoint = newly_focused?.closest?.("[data-semantic-parent]");
                            if (waypoint) {
                                const id = waypoint.dataset.semanticParent;
                                const parent = waypoint.ownerDocument.getElementById(id);
                                // console.log("following semantic parent, from", newly_focused, "\nto", parent, "\nvia", waypoint);
                                newly_focused = parent;
                                if (!parent) {
                                    console.warn("semantic parent not found with id", id);
                                    break;
                                }
                            } else {
                                break;
                            }
                        } while (true);
                    }
    
                    // Note: allowing showing window as focused from listeners inside iframe (non-root) too,
                    // in order to handle clicking an iframe when the browser window was not previously focused (e.g. after reload)
                    if (
                        newly_focused &&
                        newly_focused.window !== newly_focused && // cross-frame test for Window object
                        container_node.contains(newly_focused)
                    ) {
                        showAsFocused();
                        $w.bringToFront();
                        if (!is_root) {
                            // trigger focusin events for iframes
                            // @TODO: probably don't need showAsFocused() here since it'll be handled externally (on this simulated focusin),
                            // and might not need a lot of other logic frankly if I'm simulating focusin events
                            let el = logical_container_el;
                            while (el) {
                                // console.log("dispatching focusin event for", el);
                                el.dispatchEvent(new Event("focusin", {
                                    bubbles: true,
                                    target: el,
                                    view: el.ownerDocument.defaultView,
                                }));
                                el = el.currentView?.frameElement;
                            }
                        }
                    } else if (is_root) {
                        stopShowingAsFocused();
                    }
                }
            }
            // initial state is unfocused
        }
    
        $w.css("touch-action", "none");
    
        let minimize_target_el = null; // taskbar button (optional)
        $w.setMinimizeTarget = function (new_taskbar_button_el) {
            minimize_target_el = new_taskbar_button_el;
        };
    
        let task;
        Object.defineProperty($w, "task", {
            get() {
                return task;
            },
            set(new_task) {
                console.warn("DEPRECATED: use $w.setMinimizeTarget(taskbar_button_el) instead of setting $window.task object");
                task = new_task;
            },
        });
    
        let before_minimize;
        $w.minimize = () => {
            minimize_target_el = minimize_target_el || task?.$task[0];
            if (animating_titlebar) {
                when_done_animating_titlebar.push($w.minimize);
                return;
            }
            if ($w.is(":visible")) {
                if (minimize_target_el && !$w.hasClass("minimized-without-taskbar")) {
                    const before_rect = $w.$titlebar[0].getBoundingClientRect();
                    const after_rect = minimize_target_el.getBoundingClientRect();
                    $w.animateTitlebar(before_rect, after_rect, () => {
                        $w.hide();
                        $w.blur();
                    });
                } else {
                    // no taskbar
    
                    // @TODO: make this metrically similar to what Windows 98 does
                    // @TODO: DRY! This is copied heavily from maximize()
                    // @TODO: after minimize (without taskbar) and maximize, restore should restore original position before minimize
                    // OR should it not maximize but restore the unmaximized state? I think I tested it but I forget.
    
                    const to_width = 150;
                    const spacing = 10;
                    if ($w.hasClass("minimized-without-taskbar")) {
                        // unminimizing
                        minimize_slots[$w._minimize_slot_index] = null;
                    } else {
                        // minimizing
                        let i = 0;
                        while (minimize_slots[i]) {
                            i++;
                        }
                        $w._minimize_slot_index = i;
                        minimize_slots[i] = $w;
                    }
                    const to_x = $w._minimize_slot_index * (to_width + spacing) + 10;
                    const titlebar_height = $w.$titlebar.outerHeight();
                    let before_unminimize;
                    const instantly_minimize = () => {
                        before_minimize = {
                            position: $w.css("position"),
                            left: $w.css("left"),
                            top: $w.css("top"),
                            width: $w.css("width"),
                            height: $w.css("height"),
                        };
    
                        $w.addClass("minimized-without-taskbar");
                        if ($w.hasClass("maximized")) {
                            $w.removeClass("maximized");
                            $w.addClass("was-maximized");
                            $w.$maximize.removeClass("window-action-restore");
                            $w.$maximize.addClass("window-action-maximize");
                        }
                        $w.$minimize.removeClass("window-action-minimize");
                        $w.$minimize.addClass("window-action-restore");
                        if (before_unminimize) {
                            $w.css({
                                position: before_unminimize.position,
                                left: before_unminimize.left,
                                top: before_unminimize.top,
                                width: before_unminimize.width,
                                height: before_unminimize.height,
                            });
                        } else {
                            $w.css({
                                position: "fixed",
                                top: `calc(100% - ${titlebar_height + 5}px)`,
                                left: to_x,
                                width: to_width,
                                height: titlebar_height,
                            });
                        }
                    };
                    const instantly_unminimize = () => {
                        before_unminimize = {
                            position: $w.css("position"),
                            left: $w.css("left"),
                            top: $w.css("top"),
                            width: $w.css("width"),
                            height: $w.css("height"),
                        };
    
                        $w.removeClass("minimized-without-taskbar");
                        if ($w.hasClass("was-maximized")) {
                            $w.removeClass("was-maximized");
                            $w.addClass("maximized");
                            $w.$maximize.removeClass("window-action-maximize");
                            $w.$maximize.addClass("window-action-restore");
                        }
                        $w.$minimize.removeClass("window-action-restore");
                        $w.$minimize.addClass("window-action-minimize");
                        $w.css({ width: "", height: "" });
                        if (before_minimize) {
                            $w.css({
                                position: before_minimize.position,
                                left: before_minimize.left,
                                top: before_minimize.top,
                                width: before_minimize.width,
                                height: before_minimize.height,
                            });
                        }
                    };
    
                    const before_rect = $w.$titlebar[0].getBoundingClientRect();
                    let after_rect;
                    $w.css("transform", "");
                    if ($w.hasClass("minimized-without-taskbar")) {
                        instantly_unminimize();
                        after_rect = $w.$titlebar[0].getBoundingClientRect();
                        instantly_minimize();
                    } else {
                        instantly_minimize();
                        after_rect = $w.$titlebar[0].getBoundingClientRect();
                        instantly_unminimize();
                    }
                    $w.animateTitlebar(before_rect, after_rect, () => {
                        if ($w.hasClass("minimized-without-taskbar")) {
                            instantly_unminimize();
                        } else {
                            instantly_minimize();
                            $w.blur();
                        }
                    });
                }
            }
        };
        $w.unminimize = () => {
            if (animating_titlebar) {
                when_done_animating_titlebar.push($w.unminimize);
                return;
            }
            if ($w.hasClass("minimized-without-taskbar")) {
                $w.minimize();
                return;
            }
            if ($w.is(":hidden")) {
                const before_rect = minimize_target_el.getBoundingClientRect();
                $w.show();
                const after_rect = $w.$titlebar[0].getBoundingClientRect();
                $w.hide();
                $w.animateTitlebar(before_rect, after_rect, () => {
                    $w.show();
                    $w.bringToFront();
                    $w.focus();
                });
            }
        };
    
        let before_maximize;
        $w.maximize = () => {
            if (!options.resizable) {
                return;
            }
            if (animating_titlebar) {
                when_done_animating_titlebar.push($w.maximize);
                return;
            }
            if ($w.hasClass("minimized-without-taskbar")) {
                $w.minimize();
                return;
            }
    
            const instantly_maximize = () => {
                before_maximize = {
                    position: $w.css("position"),
                    left: $w.css("left"),
                    top: $w.css("top"),
                    width: $w.css("width"),
                    height: $w.css("height"),
                };
    
                $w.addClass("maximized");
                const $taskbar = $(".taskbar");
                const scrollbar_width = window.innerWidth - $(window).width();
                const scrollbar_height = window.innerHeight - $(window).height();
                const taskbar_height = $taskbar.length ? $taskbar.outerHeight() + 1 : 0;
                $w.css({
                    position: "fixed",
                    top: 0,
                    left: 0,
                    width: `calc(100vw - ${scrollbar_width}px)`,
                    height: `calc(100vh - ${scrollbar_height}px - ${taskbar_height}px)`,
                });
            };
            const instantly_unmaximize = () => {
                $w.removeClass("maximized");
                $w.css({ width: "", height: "" });
                if (before_maximize) {
                    $w.css({
                        position: before_maximize.position,
                        left: before_maximize.left,
                        top: before_maximize.top,
                        width: before_maximize.width,
                        height: before_maximize.height,
                    });
                }
            };
    
            const before_rect = $w.$titlebar[0].getBoundingClientRect();
            let after_rect;
            $w.css("transform", "");
            const restoring = $w.hasClass("maximized");
            if (restoring) {
                instantly_unmaximize();
                after_rect = $w.$titlebar[0].getBoundingClientRect();
                instantly_maximize();
            } else {
                instantly_maximize();
                after_rect = $w.$titlebar[0].getBoundingClientRect();
                instantly_unmaximize();
            }
            $w.animateTitlebar(before_rect, after_rect, () => {
                if (restoring) {
                    instantly_unmaximize(); // finalize in some way
                    $w.$maximize.removeClass("window-action-restore");
                    $w.$maximize.addClass("window-action-maximize");
                } else {
                    instantly_maximize(); // finalize in some way
                    $w.$maximize.removeClass("window-action-maximize");
                    $w.$maximize.addClass("window-action-restore");
                }
            });
        };
        $w.restore = () => {
            if ($w.is(".minimized-without-taskbar, .minimized")) {
                $w.unminimize();
            } else if ($w.is(".maximized")) {
                $w.maximize();
            }
        };
        // must not pass event to functions by accident; also methods may not be defined yet
        $w.$minimize?.on("click", (e)=> { $w.minimize(); });
        $w.$maximize?.on("click", (e)=> { $w.maximize(); });
        $w.$x?.on("click", (e)=> { $w.close(); });
        $w.$title_area.on("dblclick", (e)=> { $w.maximize(); });
    
        $w.css({
            position: "absolute",
            zIndex: $Window.Z_INDEX++
        });
        $w.bringToFront = () => {
            $w.css({
                zIndex: $Window.Z_INDEX++
            });
            for (const $childWindow of child_$windows) {
                $childWindow.bringToFront();
            }
        };
    
        // Keep track of last focused elements per container,
        // where containers include:
        // - window (global focus tracking)
        // - $w[0] (window-local, for restoring focus when refocusing window)
        // - any iframes that are same-origin (for restoring focus when refocusing window)
        // @TODO: should these be WeakMaps? probably.
        // @TODO: share this Map between all windows? but clean it up when destroying windows? or would a WeakMap take care of that?
        var last_focus_by_container = new Map(); // element to restore focus to, by container
        var focus_update_handlers_by_container = new Map(); // event handlers by container; note use as a flag to avoid adding multiple handlers
        var debug_svg_by_container = new Map(); // visualization
        var debug_svgs_in_window = []; // visualization
        var warned_iframes = new WeakSet(); // prevent spamming console
    
        const warn_iframe_access = (iframe, error) => {
            const log_template = (message) => [`OS-GUI.js failed to access an iframe (${element_to_string(iframe)}) for focus integration.
    ${message}
    Original error:
    `, error];
    
            let cross_origin;
            if (iframe.srcdoc) {
                cross_origin = false;
            } else {
                try {
                    const url = new URL(iframe.src);
                    cross_origin = url.origin !== window.location.origin; // shouldn't need to use iframe.ownerDocument.location.origin because intermediate iframes must be same-origin
                } catch (parse_error) {
                    console.error(...log_template(`This may be a bug in OS-GUI. Is this a cross-origin iframe? Failed to parse URL (${parse_error}).`));
                    return;
                }
            }
            if (cross_origin) {
                if (options.iframes?.ignoreCrossOrigin && !warned_iframes.has(iframe)) {
                    console.warn(...log_template(`Only same-origin iframes can work with focus integration (showing window as focused, refocusing last focused controls).
    If you can re-host the content on the same origin, you can resolve this and enable focus integration.
    You can also disable this warning by passing {iframes: {ignoreCrossOrigin: true}} to $Window.`));
                    warned_iframes.add(iframe);
                }
            } else {
                console.error(...log_template(`This may be a bug in OS-GUI, since it doesn't appear to be a cross-origin iframe.`));
            }
        };
    
        const debug_focus_tracking = (document, container_el, descendant_el, is_root) => {
            if (!$Window.DEBUG_FOCUS) {
                return;
            }
            let svg = debug_svg_by_container.get(container_el);
            if (!svg) {
                svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                svg.style.position = "fixed";
                svg.style.top = "0";
                svg.style.left = "0";
                svg.style.width = "100%";
                svg.style.height = "100%";
                svg.style.pointerEvents = "none";
                svg.style.zIndex = "100000000";
                svg.style.direction = "ltr"; // position labels correctly
                debug_svg_by_container.set(container_el, svg);
                debug_svgs_in_window.push(svg);
                document.body.appendChild(svg);
            }
            svg._container_el = container_el;
            svg._descendant_el = descendant_el;
            svg._is_root = is_root;
            animate_debug_focus_tracking();
        };
        const update_debug_focus_tracking = (svg) => {
            const container_el = svg._container_el;
            const descendant_el = svg._descendant_el;
            const is_root = svg._is_root;
    
            while (svg.lastChild) {
                svg.removeChild(svg.lastChild);
            }
            const descendant_rect = descendant_el.getBoundingClientRect?.() ?? { left: 0, top: 0, width: innerWidth, height: innerHeight, right: innerWidth, bottom: innerHeight };
            const container_rect = container_el.getBoundingClientRect?.() ?? { left: 0, top: 0, width: innerWidth, height: innerHeight, right: innerWidth, bottom: innerHeight };
            // draw rectangles with labels
            for (const rect of [descendant_rect, container_rect]) {
                const rect_el = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                rect_el.setAttribute("x", rect.left);
                rect_el.setAttribute("y", rect.top);
                rect_el.setAttribute("width", rect.width);
                rect_el.setAttribute("height", rect.height);
                rect_el.setAttribute("stroke", rect === descendant_rect ? "#f44" : "#f44");
                rect_el.setAttribute("stroke-width", "2");
                rect_el.setAttribute("fill", "none");
                if (!is_root) {
                    rect_el.setAttribute("stroke-dasharray", "5,5");
                }
                svg.appendChild(rect_el);
                const text_el = document.createElementNS("http://www.w3.org/2000/svg", "text");
                text_el.setAttribute("x", rect.left);
                text_el.setAttribute("y", rect.top + (rect === descendant_rect ? 20 : 0)); // align container text on outside, descendant text on inside
                text_el.setAttribute("fill", rect === descendant_rect ? "#f44" : "aqua");
                text_el.setAttribute("font-size", "20");
                text_el.style.textShadow = "1px 1px 1px black, 0 0 10px black";
                text_el.textContent = element_to_string(rect === descendant_rect ? descendant_el : container_el);
                svg.appendChild(text_el);
            }
            // draw lines connecting the two rects
            const lines = [
                [descendant_rect.left, descendant_rect.top, container_rect.left, container_rect.top],
                [descendant_rect.right, descendant_rect.top, container_rect.right, container_rect.top],
                [descendant_rect.left, descendant_rect.bottom, container_rect.left, container_rect.bottom],
                [descendant_rect.right, descendant_rect.bottom, container_rect.right, container_rect.bottom],
            ];
            for (const line of lines) {
                const line_el = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line_el.setAttribute("x1", line[0]);
                line_el.setAttribute("y1", line[1]);
                line_el.setAttribute("x2", line[2]);
                line_el.setAttribute("y2", line[3]);
                line_el.setAttribute("stroke", "green");
                line_el.setAttribute("stroke-width", "2");
                svg.appendChild(line_el);
            }
        };
        let debug_animation_frame_id;
        const animate_debug_focus_tracking = () => {
            cancelAnimationFrame(debug_animation_frame_id);
            if (!$Window.DEBUG_FOCUS) {
                clean_up_debug_focus_tracking();
                return;
            }
            debug_animation_frame_id = requestAnimationFrame(animate_debug_focus_tracking);
            for (const svg of debug_svgs_in_window) {
                update_debug_focus_tracking(svg);
            }
        };
        const clean_up_debug_focus_tracking = () => {
            cancelAnimationFrame(debug_animation_frame_id);
            for (const svg of debug_svgs_in_window) {
                svg.remove();
            }
            debug_svgs_in_window.length = 0;
            debug_svg_by_container.clear();
        };
    
        const refocus = (container_el = $w.$content[0]) => {
            const logical_container_el = container_el.matches(".window-content") ? $w[0] : container_el;
            const last_focus = last_focus_by_container.get(logical_container_el);
            if (last_focus) {
                last_focus.focus({ preventScroll: true });
                if (last_focus.tagName === "IFRAME") {
                    try {
                        refocus(last_focus);
                    } catch (e) {
                        warn_iframe_access(last_focus, e);
                    }
                }
                return;
            }
            const $tabstops = find_tabstops(container_el);
            const $default = $tabstops.filter(".default");
            if ($default.length) {
                $default[0].focus({ preventScroll: true });
                return;
            }
            if ($tabstops.length) {
                if ($tabstops[0].tagName === "IFRAME") {
                    try {
                        refocus($tabstops[0]); // not .contentDocument.body because we want the container tracked by last_focus_by_container
                    } catch (e) {
                        warn_iframe_access($tabstops[0], e);
                    }
                } else {
                    $tabstops[0].focus({ preventScroll: true });
                }
                return;
            }
            if (options.toolWindow && options.parentWindow) {
                options.parentWindow.triggerHandler("refocus-window");
                return;
            }
            container_el.focus({ preventScroll: true });
            if (container_el.tagName === "IFRAME") {
                try {
                    refocus(container_el.contentDocument.body);
                } catch (e) {
                    warn_iframe_access(container_el, e);
                }
            }
        };
    
        $w.on("refocus-window", () => {
            refocus();
        });
    
        // redundant events are for handling synthetic events,
        // which may be sent individually, rather than in tandem
        $w.on("pointerdown mousedown", handle_pointer_activation);
        // Note that jQuery treats some events differently, and can't listen for some synthetic events
        // but pointerdown and mousedown seem to be supported. That said, if you trigger() either,
        // addEventListener() handlers will not be called. So if I remove the dependency on jQuery,
        // it will not be possible to listen for some .trigger() events.
        // https://jsfiddle.net/1j01/ndvwts9y/1/
    
        // Assumption: focusin comes after pointerdown/mousedown
        // This is probably guaranteed, because you can prevent the default of focusing from pointerdown/mousedown
        $G.on("focusin", (e) => {
            last_focus_by_container.set(window, e.target);
            // debug_focus_tracking(document, window, e.target);
        });
    
        function handle_pointer_activation(event) {
            // console.log("handle_pointer_activation", event.type, event.target);
            $w.bringToFront();
            // Test cases where it should refocus the last focused control in the window:
            // - Click in the blank space of the window
            //   - Click in blank space again now that something's focused
            // - Click on the window title bar
            //   - Click on title bar buttons
            // - Closing a second window should focus the first window
            //   - Open a dialog window from an app window that has a tool window, then close the dialog window
            //     - @TODO: Even if the tool window has controls, it should focus the parent window, I think
            // - Clicking on a control in the window should focus said control
            // - Clicking on a disabled control in the window should focus the window
            //   - Make sure to test this with another window previously focused
            // - Simulated clicks (important for JS Paint's eye gaze and speech recognition modes)
            // - (@TODO: Should clicking a child window focus the parent window?)
            // - After potentially selecting text but not selecting anything
            // It should NOT refocus when:
            // - Clicking on a control in a different window
            // - When other event handlers set focus
            //   - Using the keyboard to focus something outside the window, such as a menu popup
            //   - Clicking a control that focuses something outside the window
            //     - Button that opens another window (e.g. Recursive Dialog button in tests)
            //     - Button that focuses a control in another window (e.g. Focus Other button in tests)
            // - Trying to select text
    
            // Wait for other pointerdown handlers and default behavior, and focusin events.
            requestAnimationFrame(() => {
                const last_focus_global = last_focus_by_container.get(window);
                // const last_focus_in_window = last_focus_by_container.get($w.$content[0]);
                // console.log("a tick after", event.type, { last_focus_in_window, last_focus_global, activeElement: document.activeElement, win_elem: $w[0] });
                // console.log("did focus change?", document.activeElement !== last_focus_global);
    
                // If something programmatically got focus, don't refocus.
                if (
                    document.activeElement &&
                    document.activeElement !== document &&
                    document.activeElement !== document.body &&
                    document.activeElement !== $w.$content[0] &&
                    document.activeElement !== last_focus_global
                ) {
                    return;
                }
                // If menus got focus, don't refocus.
                if (document.activeElement?.closest?.(".menus, .menu-popup")) {
                    // console.log("click in menus");
                    return;
                }
    
                // If the element is selectable, wait until the click is done and see if anything was selected first.
                // This is a bit of a weird compromise, for now.
                const target_style = getComputedStyle(event.target);
                if (target_style.userSelect !== "none") {
                    // Immediately show the window as focused, just don't refocus a specific control.
                    $w.$content.focus();
    
                    $w.one("pointerup pointercancel", () => {
                        requestAnimationFrame(() => { // this seems to make it more reliable in regards to double clicking
                            if (!getSelection().toString().trim()) {
                                refocus();
                            }
                        });
                    });
                    return;
                }
                // Set focus to the last focused control, which should be updated if a click just occurred.
                refocus();
            });
        }
    
        $w.on("keydown", (e) => {
            if (e.isDefaultPrevented()) {
                return;
            }
            if (e.ctrlKey || e.altKey || e.metaKey) {
                return;
            }
            // console.log("keydown", e.key, e.target);
            if (e.target.closest(".menus")) {
                // console.log("keydown in menus");
                return;
            }
            const $buttons = $w.$content.find("button");
            const $focused = $(document.activeElement);
            const focused_index = $buttons.index($focused);
            switch (e.keyCode) {
                case 40: // Down
                case 39: // Right
                    if ($focused.is("button") && !e.shiftKey) {
                        if (focused_index < $buttons.length - 1) {
                            $buttons[focused_index + 1].focus();
                            e.preventDefault();
                        }
                    }
                    break;
                case 38: // Up
                case 37: // Left
                    if ($focused.is("button") && !e.shiftKey) {
                        if (focused_index > 0) {
                            $buttons[focused_index - 1].focus();
                            e.preventDefault();
                        }
                    }
                    break;
                case 32: // Space
                case 13: // Enter (doesn't actually work in chrome because the button gets clicked immediately)
                    if ($focused.is("button") && !e.shiftKey) {
                        $focused.addClass("pressed");
                        const release = () => {
                            $focused.removeClass("pressed");
                            $focused.off("focusout", release);
                            $(window).off("keyup", keyup);
                        };
                        const keyup = (e) => {
                            if (e.keyCode === 32 || e.keyCode === 13) {
                                release();
                            }
                        };
                        $focused.on("focusout", release);
                        $(window).on("keyup", keyup);
                    }
                    break;
                case 9: { // Tab
                    // wrap around when tabbing through controls in a window
                    const $controls = find_tabstops($w.$content[0]);
                    if ($controls.length > 0) {
                        const focused_control_index = $controls.index($focused);
                        if (e.shiftKey) {
                            if (focused_control_index === 0) {
                                e.preventDefault();
                                $controls[$controls.length - 1].focus();
                            }
                        } else {
                            if (focused_control_index === $controls.length - 1) {
                                e.preventDefault();
                                $controls[0].focus();
                            }
                        }
                    }
                    break;
                }
                case 27: // Escape
                    // @TODO: make this optional, and probably default false
                    $w.close();
                    break;
            }
        });
    
        $w.applyBounds = () => {
            // TODO: outerWidth vs width? not sure
            const bound_width = Math.max(document.body.scrollWidth, innerWidth);
            const bound_height = Math.max(document.body.scrollHeight, innerHeight);
            $w.css({
                left: Math.max(0, Math.min(bound_width - $w.width(), $w.position().left)),
                top: Math.max(0, Math.min(bound_height - $w.height(), $w.position().top)),
            });
        };
    
        $w.bringTitleBarInBounds = () => {
            // Try to make the titlebar always accessible
            const bound_width = Math.max(document.body.scrollWidth, innerWidth);
            const bound_height = Math.max(document.body.scrollHeight, innerHeight);
            const min_horizontal_pixels_on_screen = 40; // enough for space past a close button
            $w.css({
                left: Math.max(
                    min_horizontal_pixels_on_screen - $w.outerWidth(),
                    Math.min(
                        bound_width - min_horizontal_pixels_on_screen,
                        $w.position().left
                    )
                ),
                top: Math.max(0, Math.min(
                    bound_height - $w.$titlebar.outerHeight() - 5,
                    $w.position().top
                )),
            });
        };
    
        $w.center = () => {
            $w.css({
                left: (innerWidth - $w.width()) / 2 + window.scrollX,
                top: (innerHeight - $w.height()) / 2 + window.scrollY,
            });
            $w.applyBounds();
        };
    
    
        $G.on("resize", $w.bringTitleBarInBounds);
    
        var drag_offset_x, drag_offset_y, drag_pointer_x, drag_pointer_y, drag_pointer_id;
        var update_drag = (e) => {
            if (drag_pointer_id === (e.pointerId ?? e.originalEvent.pointerId)) {
                drag_pointer_x = e.clientX ?? drag_pointer_x;
                drag_pointer_y = e.clientY ?? drag_pointer_y;
            }
            $w.css({
                left: drag_pointer_x + scrollX - drag_offset_x,
                top: drag_pointer_y + scrollY - drag_offset_y,
            });
        };
        $w.$titlebar.css("touch-action", "none");
        $w.$titlebar.on("selectstart", (e) => { // preventing mousedown would break :active state, I'm not sure if just selectstart is enough...
            e.preventDefault();
        });
        $w.$titlebar.on("mousedown", "button", (e) => {
            // Prevent focus on titlebar buttons.
            // This can break the :active state. In Firefox, a setTimeout before any focus() was enough,
            // but now in Chrome 95, focus() breaks the :active state too, and setTimeout only delays the brokenness,
            // so I have to use a CSS class now for the pressed state.
            refocus();
            // Emulate :enabled:active:hover state with .pressing class
            const button = e.currentTarget;
            if (!$(button).is(":enabled")) {
                return;
            }
            button.classList.add("pressing");
            const release = (event) => {
                // blur is just to handle the edge case of alt+tabbing/ctrl+tabbing away
                if (event && event.type === "blur") {
                    // if (document.activeElement?.tagName === "IFRAME") {
                    if (document.hasFocus()) {
                        return; // the window isn't really blurred; an iframe got focus
                    }
                }
                button.classList.remove("pressing");
                $G.off("mouseup blur", release);
                $(button).off("mouseenter", on_mouse_enter);
                $(button).off("mouseleave", on_mouse_leave);
            };
            const on_mouse_enter = () => { button.classList.add("pressing"); };
            const on_mouse_leave = () => { button.classList.remove("pressing"); };
            $G.on("mouseup blur", release);
            $(button).on("mouseenter", on_mouse_enter);
            $(button).on("mouseleave", on_mouse_leave);
        });
        $w.$titlebar.on("pointerdown", (e) => {
            if ($(e.target).closest("button").length) {
                return;
            }
            if ($w.hasClass("maximized")) {
                return;
            }
            const customEvent = $.Event("window-drag-start");
            $w.trigger(customEvent);
            if (customEvent.isDefaultPrevented()) {
                return; // allow custom drag behavior of component windows in jspaint (Tools / Colors)
            }
            drag_offset_x = e.clientX + scrollX - $w.position().left;
            drag_offset_y = e.clientY + scrollY - $w.position().top;
            drag_pointer_x = e.clientX;
            drag_pointer_y = e.clientY;
            drag_pointer_id = (e.pointerId ?? e.originalEvent.pointerId);
            $G.on("pointermove", update_drag);
            $G.on("scroll", update_drag);
            $("body").addClass("dragging"); // for when mouse goes over an iframe
        });
        $G.on("pointerup pointercancel", (e) => {
            if ((e.pointerId ?? e.originalEvent.pointerId) !== drag_pointer_id) { return; }
            $G.off("pointermove", update_drag);
            $G.off("scroll", update_drag);
            $("body").removeClass("dragging");
            // $w.applyBounds(); // Windows doesn't really try to keep windows on screen
            // but you also can't really drag off of the desktop, whereas here you can drag to way outside the web page.
            $w.bringTitleBarInBounds();
            drag_pointer_id = -1; // prevent bringTitleBarInBounds from making the window go to top left when unminimizing window from taskbar after previously dragging it
        });
        $w.$titlebar.on("dblclick", (e) => {
            if ($component) {
                $component.dock();
            }
        });
    
        if (options.resizable) {
    
            const HANDLE_MIDDLE = 0;
            const HANDLE_START = -1;
            const HANDLE_END = 1;
            const HANDLE_LEFT = HANDLE_START;
            const HANDLE_RIGHT = HANDLE_END;
            const HANDLE_TOP = HANDLE_START;
            const HANDLE_BOTTOM = HANDLE_END;
    
            [
                [HANDLE_TOP, HANDLE_RIGHT], // ↗
                [HANDLE_TOP, HANDLE_MIDDLE], // ↑
                [HANDLE_TOP, HANDLE_LEFT], // ↖
                [HANDLE_MIDDLE, HANDLE_LEFT], // ←
                [HANDLE_BOTTOM, HANDLE_LEFT], // ↙
                [HANDLE_BOTTOM, HANDLE_MIDDLE], // ↓
                [HANDLE_BOTTOM, HANDLE_RIGHT], // ↘
                [HANDLE_MIDDLE, HANDLE_RIGHT], // →
            ].forEach(([y_axis, x_axis]) => {
                // const resizes_height = y_axis !== HANDLE_MIDDLE;
                // const resizes_width = x_axis !== HANDLE_MIDDLE;
                const $handle = $("<div>").addClass("handle").appendTo($w);
    
                let cursor = "";
                if (y_axis === HANDLE_TOP) { cursor += "n"; }
                if (y_axis === HANDLE_BOTTOM) { cursor += "s"; }
                if (x_axis === HANDLE_LEFT) { cursor += "w"; }
                if (x_axis === HANDLE_RIGHT) { cursor += "e"; }
                cursor += "-resize";
    
                // Note: MISNOMER: innerWidth() is less "inner" than width(), because it includes padding!
                // Here's a little diagram of sorts:
                // outerWidth(true): margin, [ outerWidth(): border, [ innerWidth(): padding, [ width(): content ] ] ]
                const handle_thickness = ($w.outerWidth() - $w.width()) / 2; // padding + border
                const border_width = ($w.outerWidth() - $w.innerWidth()) / 2; // border; need to outset the handles by this amount so they overlap the border + padding, and not the content
                const window_frame_height = $w.outerHeight() - $w.$content.outerHeight(); // includes titlebar and borders, padding, but not content
                const window_frame_width = $w.outerWidth() - $w.$content.outerWidth(); // includes borders, padding, but not content
                $handle.css({
                    position: "absolute",
                    top: y_axis === HANDLE_TOP ? -border_width : y_axis === HANDLE_MIDDLE ? `calc(${handle_thickness}px - ${border_width}px)` : "",
                    bottom: y_axis === HANDLE_BOTTOM ? -border_width : "",
                    left: x_axis === HANDLE_LEFT ? -border_width : x_axis === HANDLE_MIDDLE ? `calc(${handle_thickness}px - ${border_width}px)` : "",
                    right: x_axis === HANDLE_RIGHT ? -border_width : "",
                    width: x_axis === HANDLE_MIDDLE ? `calc(100% - ${handle_thickness}px * 2 + ${border_width * 2}px)` : `${handle_thickness}px`,
                    height: y_axis === HANDLE_MIDDLE ? `calc(100% - ${handle_thickness}px * 2 + ${border_width * 2}px)` : `${handle_thickness}px`,
                    // background: x_axis === HANDLE_MIDDLE || y_axis === HANDLE_MIDDLE ? "rgba(255,0,0,0.4)" : "rgba(0,255,0,0.8)",
                    touchAction: "none",
                    cursor,
                });
    
                let rect;
                let resize_offset_x, resize_offset_y, resize_pointer_x, resize_pointer_y, resize_pointer_id;
                $handle.on("pointerdown", (e) => {
                    e.preventDefault();
    
                    $G.on("pointermove", handle_pointermove);
                    $G.on("scroll", update_resize); // scroll doesn't have clientX/Y, so we have to remember it
                    $("body").addClass("dragging"); // for when mouse goes over an iframe
                    $G.on("pointerup pointercancel", end_resize);
    
                    rect = {
                        x: $w.position().left,
                        y: $w.position().top,
                        width: $w.outerWidth(),
                        height: $w.outerHeight(),
                    };
    
                    resize_offset_x = e.clientX + scrollX - rect.x - (x_axis === HANDLE_RIGHT ? rect.width : 0);
                    resize_offset_y = e.clientY + scrollY - rect.y - (y_axis === HANDLE_BOTTOM ? rect.height : 0);
                    resize_pointer_x = e.clientX;
                    resize_pointer_y = e.clientY;
                    resize_pointer_id = (e.pointerId ?? e.originalEvent.pointerId);
    
                    $handle[0].setPointerCapture(resize_pointer_id); // keeps cursor consistent when mouse moves over other elements
    
                    // handle_pointermove(e); // was useful for checking that the offset is correct (should not do anything, if it's correct!)
                });
                function handle_pointermove(e) {
                    if ((e.pointerId ?? e.originalEvent.pointerId) !== resize_pointer_id) { return; }
                    resize_pointer_x = e.clientX;
                    resize_pointer_y = e.clientY;
                    update_resize();
                }
                function end_resize(e) {
                    if ((e.pointerId ?? e.originalEvent.pointerId) !== resize_pointer_id) { return; }
                    $G.off("pointermove", handle_pointermove);
                    $G.off("scroll", onscroll);
                    $("body").removeClass("dragging");
                    $G.off("pointerup pointercancel", end_resize);
                    $w.bringTitleBarInBounds();
                }
                function update_resize() {
                    const mouse_x = resize_pointer_x + scrollX - resize_offset_x;
                    const mouse_y = resize_pointer_y + scrollY - resize_offset_y;
                    let delta_x = 0;
                    let delta_y = 0;
                    let width, height;
                    if (x_axis === HANDLE_RIGHT) {
                        delta_x = 0;
                        width = ~~(mouse_x - rect.x);
                    } else if (x_axis === HANDLE_LEFT) {
                        delta_x = ~~(mouse_x - rect.x);
                        width = ~~(rect.x + rect.width - mouse_x);
                    } else {
                        width = ~~(rect.width);
                    }
                    if (y_axis === HANDLE_BOTTOM) {
                        delta_y = 0;
                        height = ~~(mouse_y - rect.y);
                    } else if (y_axis === HANDLE_TOP) {
                        delta_y = ~~(mouse_y - rect.y);
                        height = ~~(rect.y + rect.height - mouse_y);
                    } else {
                        height = ~~(rect.height);
                    }
                    let new_rect = {
                        x: rect.x + delta_x,
                        y: rect.y + delta_y,
                        width,
                        height,
                    };
    
                    new_rect.width = Math.max(1, new_rect.width);
                    new_rect.height = Math.max(1, new_rect.height);
    
                    // Constraints
                    if (options.constrainRect) {
                        new_rect = options.constrainRect(new_rect, x_axis, y_axis);
                    }
                    new_rect.width = Math.max(new_rect.width, options.minOuterWidth ?? 100);
                    new_rect.height = Math.max(new_rect.height, options.minOuterHeight ?? 0);
                    new_rect.width = Math.max(new_rect.width, (options.minInnerWidth ?? 0) + window_frame_width);
                    new_rect.height = Math.max(new_rect.height, (options.minInnerHeight ?? 0) + window_frame_height);
                    // prevent free movement via resize past minimum size
                    if (x_axis === HANDLE_LEFT) {
                        new_rect.x = Math.min(new_rect.x, rect.x + rect.width - new_rect.width);
                    }
                    if (y_axis === HANDLE_TOP) {
                        new_rect.y = Math.min(new_rect.y, rect.y + rect.height - new_rect.height);
                    }
    
                    $w.css({
                        top: new_rect.y,
                        left: new_rect.x,
                    });
                    $w.outerWidth(new_rect.width);
                    $w.outerHeight(new_rect.height);
                }
            });
        }
    
        $w.$Button = (text, handler) => {
            var $b = $(E("button"))
                .appendTo($w.$content)
                .text(text)
                .on("click", () => {
                    if (handler) {
                        handler();
                    }
                    $w.close();
                });
            return $b;
        };
        $w.title = title => {
            if (title) {
                $w.$title.text(title);
                $w.trigger("title-change");
                if ($w.task) {
                    $w.task.updateTitle();
                }
                return $w;
            } else {
                return $w.$title.text();
            }
        };
        $w.getTitle = () => {
            return $w.title();
        };
        let animating_titlebar = false;
        let when_done_animating_titlebar = []; // queue of functions to call when done animating,
        // so maximize() / minimize() / restore() eventually gives the same result as if there was no animation
        $w.animateTitlebar = (from, to, callback = () => { }) => {
            // flying titlebar animation
            animating_titlebar = true;
            const $eye_leader = $w.$titlebar.clone(true);
            $eye_leader.find("button").remove();
            $eye_leader.appendTo("body");
            const duration_ms = $Window.OVERRIDE_TRANSITION_DURATION ?? 200; // TODO: how long?
            const duration_str = `${duration_ms}ms`;
            $eye_leader.css({
                transition: `left ${duration_str} linear, top ${duration_str} linear, width ${duration_str} linear, height ${duration_str} linear`,
                position: "fixed",
                zIndex: 10000000,
                pointerEvents: "none",
                left: from.left,
                top: from.top,
                width: from.width,
                height: from.height,
            });
            setTimeout(() => {
                $eye_leader.css({
                    left: to.left,
                    top: to.top,
                    width: to.width,
                    height: to.height,
                });
            }, 5);
            let handled_transition_completion = false;
            const handle_transition_completion = () => {
                if (handled_transition_completion) {
                    return; // ignore multiple calls (an idempotency pattern)
                } else {
                    handled_transition_completion = true;
                }
                animating_titlebar = false;
                $eye_leader.remove();
                callback();
                when_done_animating_titlebar.shift()?.(); // relies on animating_titlebar = false;
            };
            $eye_leader.on("transitionend transitioncancel", handle_transition_completion);
            setTimeout(handle_transition_completion, duration_ms * 1.2);
        };
        $w.close = (force) => {
            if (force && force !== true) {
                throw new TypeError("force must be a boolean or undefined, not " + Object.prototype.toString.call(force));
            }
            if (!force) {
                var e = $.Event("close");
                $w.trigger(e);
                if (e.isDefaultPrevented()) {
                    return;
                }
            }
            if ($component) {
                $component.detach();
            }
            $w.closed = true;
            $event_target.triggerHandler("closed");
            $w.trigger("closed");
            // TODO: change usages of "close" to "closed" where appropriate
            // and probably rename the "close" event ("before[-]close"? "may-close"? "close-request"?)
    
            // MUST be after any events are triggered!
            $w.remove();
    
            // TODO: support modals, which should focus what was focused before the modal was opened.
            // (Note: must consider the element being removed from the DOM, or hidden, or made un-focusable)
            // (Also: modals should steal focus / be brought to the front when focusing the parent window, and the parent window's content should be inert/uninteractive)
            
            // Focus next-topmost window
            var $next_topmost = $($(".window:visible").toArray().sort((a, b) => b.style.zIndex - a.style.zIndex)[0]);
            $next_topmost.triggerHandler("refocus-window");
    
            // Cleanup
            clean_up_debug_focus_tracking();
        };
        $w.closed = false;
    
        let current_menu_bar;
        // @TODO: should this be like setMenus(menu_definitions)?
        // It seems like setMenuBar(menu_bar) might be prone to bugs
        // trying to set the same menu bar on multiple windows.
        $w.setMenuBar = (menu_bar) => {
            // $w.find(".menus").remove(); // ugly, if only because of the class name haha
            if (current_menu_bar) {
                current_menu_bar.element.remove();
            }
            if (menu_bar) {
                $w.$titlebar.after(menu_bar.element);
                menu_bar.setKeyboardScope($w[0]);
                current_menu_bar = menu_bar;
            }
        };
    
        if (options.title) {
            $w.title(options.title);
        }
    
        if (!$component) {
            $w.center();
        }
    
        // mustHaveMethods($w, windowInterfaceMethods);
    
        return $w;
    }
    
    function $FormWindow(title) {
        var $w = new $Window();
    
        $w.title(title);
        $w.$form = $(E("form")).appendTo($w.$content);
        $w.$main = $(E("div")).appendTo($w.$form);
        $w.$buttons = $(E("div")).appendTo($w.$form).addClass("button-group");
    
        $w.$Button = (label, action) => {
            var $b = $(E("button")).appendTo($w.$buttons).text(label);
            $b.on("click", (e) => {
                // prevent the form from submitting
                // @TODO: instead, prevent the form's submit event
                e.preventDefault();
    
                action();
            });
    
            $b.on("pointerdown", () => {
                $b.focus();
            });
    
            return $b;
        };
    
        return $w;
    }
    
    exports.$Window = $Window;
    exports.$FormWindow = $FormWindow;
    
    })(window);
    </script>
<script>
// Prefer a function injected from outside an iframe,
// which will make dialogs that can go outside the iframe.
// Note that this API must be kept in sync with the version in jspaint.

// Note `defaultMessageBoxTitle` handling in make_iframe_window
// Any other default parameters need to be handled there (as it works now)

var chord_audio = new Audio("/projects/solitaire/audio/CHORD.WAV");

window.showMessageBox = window.showMessageBox || (({
	title = window.defaultMessageBoxTitle ?? "Alert",
	message,
	messageHTML,
	buttons = [{ label: "OK", value: "ok", default: true }],
	iconID = "warning", // "error", "warning", "info", or "nuke" for deleting files/folders
	windowOptions = {}, // for controlling width, etc.
}) => {
	let $window, $message;
	const promise = new Promise((resolve, reject) => {
		$window = new $Window(Object.assign({
			title,
			resizable: false,
			innerWidth: 400,
			maximizeButton: false,
			minimizeButton: false,
		}, windowOptions));
		// $window.addClass("dialog-window horizontal-buttons");
		$message =
			$("<div>").css({
				textAlign: "left",
				fontFamily: "MS Sans Serif, Arial, sans-serif",
				fontSize: "14px",
				marginTop: "22px",
				flex: 1,
				minWidth: 0, // Fixes hidden overflow, see https://css-tricks.com/flexbox-truncated-text/
				whiteSpace: "normal", // overriding .window:not(.squish)
			});
		if (messageHTML) {
			$message.html(messageHTML);
		} else if (message) { // both are optional because you may populate later with dynamic content
			$message.text(message).css({
				whiteSpace: "pre-wrap",
				wordWrap: "break-word",
			});
		}
		$("<div>").append(
			$("<img width='32' height='32'>").attr("src", `../../images/icons/${iconID}-32x32-8bpp.png`).css({
				margin: "16px",
				display: "block",
			}),
			$message
		).css({
			display: "flex",
			flexDirection: "row",
		}).appendTo($window.$content);

		$window.$content.css({
			textAlign: "center",
		});
		for (const button of buttons) {
			const $button = $window.$Button(button.label, () => {
				button.action?.(); // API may be required for using user gesture requiring APIs
				resolve(button.value);
				$window.close(); // actually happens automatically
			});
			if (button.default) {
				$button.addClass("default");
				$button.focus();
				setTimeout(() => $button.focus(), 0); // @TODO: why is this needed? does it have to do with the iframe window handling?
			}
			$button.css({
				minWidth: 75,
				height: 23,
				margin: "16px 2px",
			});
		}
		$window.on("focusin", "button", (event) => {
			$(event.currentTarget).addClass("default");
		});
		$window.on("focusout", "button", (event) => {
			$(event.currentTarget).removeClass("default");
		});
		$window.on("closed", () => {
			resolve("closed"); // or "cancel"? do you need to distinguish?
		});
		$window.center();
	});
	promise.$window = $window;
	promise.$message = $message;
	promise.promise = promise; // for easy destructuring
	try {
		chord_audio.play();
	} catch (error) {
		console.log(`Failed to play ${chord_audio.src}: `, error);
	}
	return promise;
});

window.alert = (message) => {
	showMessageBox({ message });
};</script>
<script>defaultMessageBoxTitle = "Solitaire";</script>
<script>var menus = {
	"&Game": [
		{
			item: "&Deal",
			shortcut: "F2",
			action: ()=> { resetGame(); },
			description: "Deal a new game",
		},
		// Don't want to imply you can undo by showing this option
		// {
		// 	item: "&Undo",
		// 	shortcut: "",
		// 	enabled: false,
		// 	action: ()=> { undo(); },
		// 	description: "Undo last action",
		// },
		{
			item: "De&ck...",
			shortcut: "",
			enabled: false,
			action: ()=> {},
			description: "Choose new deck back",
		},
		{
			item: "&Options...",
			shortcut: "",
			enabled: false,
			action: ()=> {},
			description: "Change Solitaire options",
		},
		MENU_DIVIDER,
		{
			item: "E&xit",
			shortcut: "",
			action: ()=> {
				close();
			},
			description: "Exit Solitaire",
		}
	],
	"&Help": [
		// {
		// 	item: "&Help Topics",
		// 	action: ()=> {
		// 		var show_help = window.show_help;
		// 		try {
		// 			show_help = parent.show_help;
		// 		} catch(e) {}
		// 		if (show_help === undefined) {
		// 			return alert("Help Topics only works when inside of the 98.js.org desktop.");
		// 		}
		// 		show_help({
		// 			title: "Solitaire Help",
		// 			contentsFile: "help/solitaire-help/solitaire.hhc",
		// 			root: "help/solitaire-help",
		// 		});
		// 	},
		// 	description: "Displays Help for the current task or command.",
		// },
		// or more detailedly:
		// {
		// 	item: "&Contents",
		// 	enabled: false,
		// 	action: ()=> {},
		// 	description: "Index of Solitaire help topics"
		// },
		// {
		// 	item: "&Search for Help on...",
		// 	enabled: false,
		// 	action: ()=> {},
		// 	description: "Search the Help Engine for a specific topic"
		// },
		// {
		// 	item: "&How to Use Help",
		// 	enabled: false,
		// 	action: ()=> {},
		// 	description: "Help using help"
		// },
		// MENU_DIVIDER,
		{
			item: "&About Solitaire...",
			action: ()=> {
				window.open("https://gamenaz.com");
			},
			description: "About Solitaire"
		},
	],
};

var go_outside_frame = false;
if(frameElement){
	try{
		if(parent.MenuBar){
			MenuBar = parent.MenuBar;
			go_outside_frame = true;
		}
	}catch(e){}
}
var menu_bar = new MenuBar(menus);
if (go_outside_frame) {
	frameElement.parentElement.insertBefore(menu_bar.element, frameElement);
} else {
	document.body.prepend(menu_bar.element);
}
</script>
<script>const gameEl = document.getElementById('js-solitaire');
const dealPileEl = document.getElementById('js-deck-pile');
const dealEl = document.getElementById('js-deck-deal');
const upperContainerEl = document.getElementById('js-upper');
const deskContainerEl = document.getElementById('js-board');
const deckPileEl = document.getElementById('js-deck-pile');

const cardWidth = 71;
const cardHeight = 96;
const state = {
    // clubs (♣), diamonds (♦), hearts (♥) and spades (♠)
    types: ['c', 'd', 'h', 's'],
    // 0 (black), 1 (red)
    colors: {'c': 0, 'd': 1, 'h': 1, 's': 0},
    cards: [
        // { el: null, type: 's', number: 0, facingUp: false }, {...}
    ],
    // dealer deck
    deal: {
        pile: {
            el: null,
            cards: [/* 0, 1, ... */]
        },
        deal: {
            el: null,
            cards: [/* 0, 1, ... */]
        },
    },
    // finish deck
    finish: [
        // { el: null, cards: [ 0, 1, ... ] }, {...}
    ],
    // playing desk
    desk: [
        // { el: null, cards: [ 0, 1, ... ]}, {...}
    ],
    // move target
    target: null,
    // moving
    moving: {
        card: {},
        element: null,
        index: -1,
        capture: false,
        container: {
            cards: [/* 0, 1, ... */]
        },
        target: null,
        origin: {},
        offset: {
            x: 0,
            y: 0,
        },
        destinations: []
    }
};

const getCard = index => state.cards[index];

const faceUp = card => {
    state.cards[card].facingUp = true;
    requestAnimationFrame(() => {
        state.cards[card].el.classList.add('card--front');
        state.cards[card].el.classList.remove('card--back');
    });
};

const faceDown = card => {
    state.cards[card].facingUp = false;
    state.cards[card].el.classList.remove('card--front');
    state.cards[card].el.classList.add('card--back');
};

const faceUpLastOnDesk = index => {
    const card = getLastOnDesk(index);
    if (card !== null) {
        faceUp(card);
    }
};

const appendToCard = (target, card) => {
    state.cards[target].el.appendChild(
        state.cards[card].el
    )
};

const appendToDesk = (desk, card) => {
    state.desk[desk].el.appendChild(
        state.cards[card].el
    )
};

const getLastOnDesk = desk => {
    const l = state.desk[desk].cards.length;
    if (l > 0) {
        return state.desk[desk].cards[l - 1];
    }
    return null;
};

const getLastOnPile = (pile, index) => {
    const l = state[pile][index].cards.length;
    if (l > 0) {
        const card = state[pile][index].cards[l - 1];
        return state.cards[card];
    }
    return {};
};

const getCardLocation = card => {
    for (let i = 0; i < 7; i++) {
        const index = state.desk[i].cards.indexOf(card);
        if (index > -1) {
            return {
                location: 'desk',
                pile: i,
                index: index
            }
        }
    }

    for (let i = 0; i < 4; i++) {
        const index = state.finish[i].cards.indexOf(card);
        if (index > -1) {
            return {
                location: 'finish',
                pile: i,
                index: index
            }
        }
    }

    for (let i of ['deal', 'pile']) {
        const index = state.deal[i].cards.indexOf(card);
        if (index > -1) {
            return {
                location: 'deal',
                pile: i,
                index: index
            }
        }
    }
    // debugger;
    // 'Card not found!';
};

const getSubCards = card => {
    const { location, pile, index } = getCardLocation(card);

    return state[location][pile].cards.filter(
        (elem, i, array) => array.indexOf(elem) > index
    );
};

const getPile = (pile, index) => {
    return state[pile][index];
};

const moveCardTo = (dest, i, card) => {
    const {
        location,
        pile,
        index
    } = getCardLocation(card);

    const moving = state[location][pile].cards.filter(
        (elem, i, array) => array.indexOf(elem) >= index
    );

    // remove from source
    state[location][pile].cards = state[location][pile].cards.filter(
        (elem, i, array) => moving.indexOf(elem) === -1
    );

    // append to destination
    state[dest][i].cards = state[dest][i].cards.concat(moving);

    // console.log(state);
};

const canBePlacedOnCard = (child, parent) => {
    const { type, number } = getCard(child);
    const {
        type: parentType,
        number: parentNumber
    } = getCard(parent);
    return (
        (parentNumber - 1) === number &&
        state.colors[parentType] !== state.colors[type]
    );
};

const placeCardTo = (dest, index, card) => {
    function remove(array, element) {
        const index = array.indexOf(element);

        if (index !== -1) {
            array.splice(index, 1);
        }
    }
    state[dest][index].cards.push(card);
    remove(state.deal.pile.cards, card);
};

function dealCards() {
    let card = 0;
    for (let i = 0; i < 7; i++) {
        for (let j = i; j < 7; j++) {
            const last = getLastOnDesk(j);
            if (last !== null) {
                appendToCard(last, card)
            } else {
                appendToDesk(j, card);
            }

            placeCardTo('desk', j, card);

            if (j === i) {
                faceUp(card);
            }
            card++;
        }
    }
}

function shuffleInPlace(a) {
    for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
    }
}

function resetGame() {
    // clear decks
    for (let i = 0; i < 7; i++) {
        state.desk[i].cards = [];
    }
    for (let i = 0; i < 4; i++) {
        state.finish[i].cards = [];
    }
    state.deal.pile.cards = [];
    state.deal.deal.cards = [];

    // shuffle cards
    shuffleInPlace(state.cards);

    // re-assign indexes
    requestAnimationFrame(() => {
        for (let i = 0, l = state.cards.length; i < l; i++) {
            const { facingUp, el } = state.cards[i];
            state.deal.pile.cards.push(i);

            el.onpointerdown = captureMove(i);
            el.onpointerup = releaseMove;
            el.onclick = handleClick(i);

            if (facingUp) {
                faceDown(i);
            }
            dealPileEl.appendChild(el);
        }
        dealCards();
    });
}

const handleClick = index => event => {
    event.stopPropagation();
    const { el, facingUp } = getCard(index);

    if (state.moving.capture) return;
    releaseMove();

    if (facingUp) {
        const { location, pile } = getCardLocation(index);

        if (location === 'deal' && pile === 'deal') {
            const {
                el: lastEl
            } = getLastOnPile('deal', 'deal');
            if (el !== lastEl) return;
        }

        const destinations = getAvailableDestinations(index, true);

        if (destinations.length > 0) {
            const {
                target,
                el: targetEl
            } = destinations[0];

            const {
                dest: destTarget,
                pile: pileTarget,
                card: cardTarget
            } = target;

            moveCardTo(destTarget, pileTarget, cardTarget);

            // face up last cards on desk
            if (location === 'desk') {
                faceUpLastOnDesk(pile);
            }
            targetEl.appendChild(el);
        } else {
            return;
        }
        gameFinish();
    } else {
        // is on deal deck
        const { location, pile } = getCardLocation(index);
        if (location === 'deal' && pile === 'pile') {
            const max = state.deal.pile.cards.length - 1;
            const min = Math.max(-1, max - 3);

            for (let i = max; i > min; i--) {
                const card = state.deal.pile.cards[i];
                const { el } = getCard(card);
                faceUp(card);
                moveCardTo('deal', 'deal', card);
                dealEl.appendChild(el);
            }
        }
    }
};

function restartDeal() {
    state.deal.pile.cards = state.deal.deal.cards;
    state.deal.deal.cards = [];

    for (const card of state.deal.pile.cards) {
        const { el } = getCard(card);
        faceDown(card);
        deckPileEl.appendChild(el);
    }
}

function getPointerPosition(event) {
    return {
        x: event.pageX,
        y: event.pageY
    };
}

const handleMove = event => {
    if (state.moving.capture) {
        const el = state.moving.element;
        const { x, y } = getPointerPosition(event);

        el.style.left = `${x - state.moving.offset.x}px`;
        el.style.top = `${y - state.moving.offset.y}px`;
    }
};

const startMovingPosition = event => {
    const el = state.moving.element;
    const { x, y } = getPointerPosition(event);
    const { top, left } = el.getBoundingClientRect();
    el.classList.add('card--moving');

    state.moving.offset = {
        x: x - left,
        y: y - top,
    };

    el.style.left = `${x - state.moving.offset.x}px`;
    el.style.top = `${y - state.moving.offset.y - 5}px`;
};

let moving;
const captureMove = index => event => {
    event.preventDefault();
    event.stopPropagation();
    const { el, facingUp } = getCard(index);
    if (facingUp) {
        const { location, pile } = getCardLocation(index);
        if (location === 'deal' && pile === 'deal') {
            const { el: lastEl } = getLastOnPile('deal', 'deal');
            if (el !== lastEl) {
                return false;
            }
        }
        moving = setTimeout(() => {
            state.moving.element = event.target;
            state.moving.capture = true;
            state.moving.index = index;
            state.moving.card = getCard(index);
            state.moving.origin = getCardLocation(index);

            startMovingPosition(event);

            const destinations = getAvailableDestinations(index);
            state.moving.destinations = destinations;

            for (const dest of destinations) {
                dest.el.classList.add('finish-dest');
            }

            for (let i = 0, l = destinations.length; i < l; i++) {
                const { top, left, width, height } = destinations[i].el.getBoundingClientRect();
                state.moving.destinations[i].offset = {
                    top: top,
                    left: left,
                    width: width,
                    height: height,
                }
            }

            // console.log(state.moving.destinations);
        }, 200);
    }
};

const dropCard = (x, y) => {
    for (const destination of state.moving.destinations) {
        const { width, height, left, top } = destination.offset;
        destination.el.classList.remove('finish-dest');
        if (
            (x > left && x < left + width) &&
            (y > top && y < top + height)
        ) {
            const { dest, pile, card } = destination.target;
            moveCardTo(dest, pile, card);

            destination.el.appendChild(state.moving.element);

            // check game finish
            gameFinish();

            // face up last on desk
            const {
                location: originLocation,
                pile: originPile
            } = state.moving.origin;

            if (originLocation === 'desk') {
                faceUpLastOnDesk(originPile);
            }
        }
    }
};

let release;
const releaseMove = event => {
    clearTimeout(moving);
    clearTimeout(release);
    if (state.moving.capture) {
        release = setTimeout(() => {
            const { x, y } = getPointerPosition(event);
            requestAnimationFrame(() => {
                dropCard(x, y);

                state.moving.element.classList.remove('card--moving');
                state.moving.element.style.left = '';
                state.moving.element.style.top = '';
                state.moving.element = null;
                state.moving.capture = false;
                // console.log('release');
            });
        }, 100);
    }
};

const getAvailableDestinations = (index, first = false) => {
    const { type, number } = getCard(index);
    const destinations = [];
    if (number === 1) { // aces
        // finish pile
        for (let i = 0; i < 4; i++) {
            const { cards, el} = getPile('finish', i);
            if (cards.length === 0) {
                destinations.push({
                    el: el,
                    target: {
                        dest: 'finish',
                        pile: i,
                        card: index
                    }
                });

                if (first) return destinations;
            }
        }
    }
    // other cards
    // move to finish pile
    const subCards = getSubCards(index);
    if (!subCards.length > 0) {
        for (let i = 0; i < 4; i++) {
            const l = state.finish[i].cards.length;
            if (l + 1 === number) {
                const {
                    type: lastType
                } = getLastOnPile('finish', i);

                if (lastType === type) {
                    destinations.push({
                        el: state.finish[i].el,
                        target: {
                            dest: 'finish',
                            pile: i,
                            card: index
                        }
                    });
                    if (first) return destinations;
                    break;
                }
            }
        }
    }
    // desk pile
    for (let i = 0; i < 7; i++) {
        const last = getLastOnDesk(i);
        if (last !== null) {
            if (canBePlacedOnCard(index, last)) {
                destinations.push({
                    el: state.cards[last].el,
                    target: {
                        dest: 'desk',
                        pile: i,
                        card: index
                    }
                });
                if (first) return destinations;
            }
        } else { // empty desk, accepts only kings
            if (number === 13) { // kings
                destinations.push({
                    el: state.desk[i].el,
                    target: {
                        dest: 'desk',
                        pile: i,
                        card: index
                    }
                });
                if (first) return destinations;
            }
        }
    }
    return destinations;
};


const gameFinish = () => {
    // game finish check
    for (let i = 3; i >= 0; i--) {
        const l = state.finish[i].cards.length;
        if (l < 13) return;
    }

    win();
};

const spritesheetImage = document.createElement('img');
spritesheetImage.src = "./src/spritesheet.png";

const win = () => {
    const boundingRect = gameEl.getBoundingClientRect();
    const canvas = document.createElement('canvas');
    canvas.style.position = 'absolute';
    canvas.width = boundingRect.width;
    canvas.height = boundingRect.height;
    gameEl.appendChild(canvas);

    const context = canvas.getContext('2d');
    let card = 52;
    const particles = [];

    const drawCard = (x, y, spriteX, spriteY) => {
        context.drawImage(
            spritesheetImage,
            spriteX,
            spriteY,
            cardWidth,
            cardHeight,
            x,
            y,
            cardWidth,
            cardHeight
        );
    };

    const Particle = function (id, x, y, sx, sy) {
        if (sx === 0) sx = 2;
        const spriteX = Math.floor(id / 4) * cardWidth;
        const spriteY = ( id % 4 ) * cardHeight;

        // initial position of the card
        drawCard(x, y, spriteX, spriteY);

        this.update = () => {
            x += sx;
            y += sy;

            // is particle out of canvas
            if (x < -cardWidth || x > (canvas.width + cardWidth)) {
                const index = particles.indexOf(this);
                particles.splice(index, 1);
                return false;
            }

            // bounce from floor
            if (y > canvas.height - cardHeight) {
                y = canvas.height - cardHeight;
                sy = -sy * 0.85;
            }
            sy += 0.98;

            drawCard(
                Math.floor(x),
                Math.floor(y),
                spriteX,
                spriteY
            );
            return true;
        };
    };

    const throwCard = (x, y) => {
        if (card < 1) return;
        card--;
        const particle = new Particle(
            card,
            x,
            y,
            Math.floor(Math.random() * 6 - 3) * 2,
            -Math.random() * 16
        );

        // const particle = new Particle(card, x, y, 0, 0);
        particles.push(particle);
    };

    let throwInterval = [];
    for (let i = 0; i < 4; i++) {
        const { left, top } = state.finish[i].el.getBoundingClientRect();
        throwInterval[i] = setInterval(function () {
            throwCard(left - boundingRect.left, top - boundingRect.top);
        }, 1000);
        // throwCard(left - boundingRect.left, top - boundingRect.top);
    }

    const updateInterval = setInterval(function () {
        let i = 0, l = particles.length;
        while (i < l) {
            particles[i].update() ? i++ : l--;
        }
        // clearInterval(updateInterval)
    }, 1000 / 60);

    function removeAnimation(event) {
        event.preventDefault();
        clearInterval(updateInterval);
        for (let i = 0; i < 4; i++) {
            clearInterval(throwInterval[i]);
        }
        canvas.parentNode.removeChild(canvas);
        document.removeEventListener('click', removeAnimation)
    }
    document.addEventListener('click', removeAnimation, false);
};

function initSolitaire() {

    const backStyleIndex = Math.floor(Math.random() * 12) + 1;
    document.body.style.setProperty(
        "--background-position-facing-down",
        `${cardWidth * -backStyleIndex}px ${cardHeight * -4}px`
    );

    // create all cards
    for (let i = 0; i < 4; i++) {
        for (let j = 1; j <= 13; j++) {
            const el = document.createElement('div');
            el.classList.add(
                'card',
                `card--${state.types[i]}-${j}`,
                'card--back'
            );
            el.style.setProperty(
                "--background-position-facing-up",
                `${cardWidth * -(j - 1)}px ${cardHeight * -i}px`
            );


            state.cards.push({
                el: el,
                type: state.types[i],
                number: j,
                facingUp: false
            });
        }
    }

    // create aces decks
    for (let i = 0; i < 4; i++) {
        const el = document.createElement('div');
        el.classList.add(
            'aces',
            `aces--${i}`
        );
        state.finish.push({
            el: el,
            cards: []
        });
        upperContainerEl.appendChild(el);
    }

    // create desk decks
    for (let i = 0; i < 7; i++) {
        const el = document.createElement('div');
        el.classList.add(
            'seven',
            `seven--${i}`
        );
        state.desk.push({
            el: el,
            cards: []
        });
        deskContainerEl.appendChild(el);
    }

    dealPileEl.onclick = restartDeal;
    window.onpointermove = handleMove;
    window.onpointerup = releaseMove;

    resetGame();
}

window.onload = initSolitaire;
window.resetGame = resetGame;
</script>
</body>
</html>
